#!/usr/bin/env python3
"""
Analizador de vulnerabilidades principal
Coordina el análisis y genera reportes agregados
"""

from datetime import datetime
from typing import Dict, List, Any
import numpy as np

from .vulnerability_analyzer_base import VulnerabilityType
from .vulnerability_analyzer_modules import ModuleVulnerabilityAnalyzer

class VulnerabilityAnalyzer(ModuleVulnerabilityAnalyzer):
    """Analizador principal de vulnerabilidades"""
    
    def analyze_all_modules(self, assessment_results: Dict[str, Any]) -> Dict[str, Any]:
        """Analizar vulnerabilidades en todos los módulos"""
        self.logger.info("Iniciando análisis de vulnerabilidades")
        
        # Analizar cada módulo
        modules = assessment_results.get('modules', {})
        
        # IAM vulnerabilities
        if 'iam' in modules:
            self.analyze_iam_vulnerabilities(modules['iam'])
        
        # Network vulnerabilities
        if 'network' in modules:
            self.analyze_network_vulnerabilities(modules['network'])
        
        # Storage vulnerabilities
        if 'storage' in modules:
            self.analyze_storage_vulnerabilities(modules['storage'])
        
        # Monitoring vulnerabilities
        if 'monitoring' in modules:
            self.analyze_monitoring_vulnerabilities(modules['monitoring'])
        
        # Cross-module vulnerabilities
        self.analyze_cross_module_vulnerabilities(modules)
        
        # Análisis agregado
        vulnerability_analysis = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities_by_severity': self._group_by_severity(),
            'vulnerabilities_by_type': self._group_by_type(),
            'critical_vulnerabilities': self._get_critical_vulnerabilities(),
            'exploitability_analysis': self._analyze_exploitability(),
            'attack_surface_analysis': self._analyze_attack_surface(),
            'vulnerability_chains': self._identify_vulnerability_chains(),
            'remediation_complexity': self._analyze_remediation_complexity(),
            'patch_priority_list': self._generate_patch_priority(),
            'security_debt_analysis': self._analyze_security_debt(),
            'timestamp': datetime.now().isoformat()
        }
        
        self.logger.info(f"Análisis de vulnerabilidades completado. Total: {len(self.vulnerabilities)}")
        return vulnerability_analysis
    
    def _group_by_severity(self) -> Dict[str, List[Dict]]:
        """Agrupar vulnerabilidades por severidad"""
        grouped = {
            'CRITICAL': [],
            'HIGH': [],
            'MEDIUM': [],
            'LOW': []
        }
        
        for vuln in self.vulnerabilities:
            vuln_summary = {
                'id': vuln.id,
                'title': vuln.title,
                'cvss_score': vuln.cvss_score,
                'type': vuln.type.value,
                'affected_resources_count': len(vuln.affected_resources)
            }
            grouped[vuln.severity].append(vuln_summary)
        
        # Ordenar por CVSS score
        for severity in grouped:
            grouped[severity].sort(key=lambda x: x['cvss_score'], reverse=True)
        
        return grouped
    
    def _group_by_type(self) -> Dict[str, Dict]:
        """Agrupar vulnerabilidades por tipo"""
        grouped = {}
        
        for vuln in self.vulnerabilities:
            vuln_type = vuln.type.value
            if vuln_type not in grouped:
                grouped[vuln_type] = {
                    'count': 0,
                    'severities': {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0},
                    'vulnerabilities': []
                }
            
            grouped[vuln_type]['count'] += 1
            grouped[vuln_type]['severities'][vuln.severity] += 1
            grouped[vuln_type]['vulnerabilities'].append(vuln.id)
        
        return grouped
    
    def _get_critical_vulnerabilities(self) -> List[Dict]:
        """Obtener vulnerabilidades críticas con detalles completos"""
        critical_vulns = []
        
        for vuln in self.vulnerabilities:
            if vuln.severity == 'CRITICAL':
                critical_vulns.append({
                    'id': vuln.id,
                    'title': vuln.title,
                    'description': vuln.description,
                    'cvss_score': vuln.cvss_score,
                    'cve_ids': vuln.cve_ids,
                    'affected_resources': vuln.affected_resources,
                    'immediate_action': vuln.remediation['steps'][0],
                    'estimated_effort': vuln.remediation['effort_hours']
                })
        
        return sorted(critical_vulns, key=lambda x: x['cvss_score'], reverse=True)
    
    def _analyze_exploitability(self) -> Dict[str, Any]:
        """Analizar facilidad de explotación de vulnerabilidades"""
        exploitability = {
            'easily_exploitable': [],
            'moderately_exploitable': [],
            'difficult_to_exploit': [],
            'exploit_chains': []
        }
        
        for vuln in self.vulnerabilities:
            exploit_score = self._calculate_exploit_score(vuln)
            
            vuln_exploit = {
                'vuln_id': vuln.id,
                'title': vuln.title,
                'exploit_score': exploit_score,
                'public_exploits': len(vuln.cve_ids) > 0,
                'requires_auth': self._requires_authentication(vuln),
                'network_accessible': self._is_network_accessible(vuln)
            }
            
            if exploit_score >= 8:
                exploitability['easily_exploitable'].append(vuln_exploit)
            elif exploit_score >= 5:
                exploitability['moderately_exploitable'].append(vuln_exploit)
            else:
                exploitability['difficult_to_exploit'].append(vuln_exploit)
        
        # Identificar cadenas de explotación
        exploitability['exploit_chains'] = self._identify_exploit_chains()
        
        return exploitability
    
    def _calculate_exploit_score(self, vuln) -> float:
        """Calcular score de explotabilidad (0-10)"""
        score = 5.0  # Base
        
        # Factores que aumentan explotabilidad
        if vuln.type == VulnerabilityType.EXPOSURE:
            score += 2
        if vuln.type == VulnerabilityType.AUTHENTICATION:
            score += 1.5
        if len(vuln.cve_ids) > 0:
            score += 1.5  # Exploits públicos conocidos
        if 'internet' in vuln.description.lower() or '0.0.0.0/0' in str(vuln.evidence):
            score += 2
        
        # Factores que reducen explotabilidad
        if vuln.type == VulnerabilityType.COMPLIANCE:
            score -= 2
        if vuln.false_positive_likelihood > 0.5:
            score -= 1
        
        return min(max(score, 0), 10)
    
    def _requires_authentication(self, vuln) -> bool:
        """Determinar si la vulnerabilidad requiere autenticación para explotar"""
        no_auth_types = [VulnerabilityType.EXPOSURE, VulnerabilityType.CONFIGURATION]
        return vuln.type not in no_auth_types
    
    def _is_network_accessible(self, vuln) -> bool:
        """Determinar si la vulnerabilidad es accesible por red"""
        network_types = [VulnerabilityType.EXPOSURE, VulnerabilityType.CONFIGURATION,
                        VulnerabilityType.AUTHENTICATION]
        return vuln.type in network_types
    
    def _identify_vulnerability_chains(self) -> List[Dict]:
        """Identificar cadenas de vulnerabilidad potenciales"""
        chains = []
        
        # Cadena 1: Sin MFA -> Acceso privilegiado -> Movimiento lateral
        mfa_vulns = [v for v in self.vulnerabilities if 'MFA' in v.title]
        priv_vulns = [v for v in self.vulnerabilities if 'privileg' in v.title.lower()]
        
        if mfa_vulns and priv_vulns:
            chains.append({
                'name': 'Compromiso de cuenta privilegiada',
                'description': 'Explotación de cuentas sin MFA para obtener acceso administrativo',
                'steps': [
                    mfa_vulns[0].id,
                    priv_vulns[0].id if priv_vulns else 'Escalación de privilegios'
                ],
                'impact': 'Control total del ambiente',
                'likelihood': 'Alta'
            })
        
        # Cadena 2: Puerto expuesto -> Sin cifrado -> Exfiltración de datos
        exposed_vulns = [v for v in self.vulnerabilities if v.type == VulnerabilityType.EXPOSURE]
        crypto_vulns = [v for v in self.vulnerabilities if v.type == VulnerabilityType.ENCRYPTION]
        
        if exposed_vulns and crypto_vulns:
            chains.append({
                'name': 'Exfiltración de datos sensibles',
                'description': 'Acceso a servicios expuestos para extraer datos no cifrados',
                'steps': [
                    exposed_vulns[0].id,
                    crypto_vulns[0].id
                ],
                'impact': 'Pérdida de confidencialidad de datos',
                'likelihood': 'Media-Alta'
            })
        
        return chains
    
    def _analyze_attack_surface(self) -> Dict[str, Any]:
        """Analizar superficie de ataque"""
        attack_surface = {
            'external_surface': {
                'exposed_services': 0,
                'public_ips': 0,
                'open_ports': 0,
                'vulnerable_protocols': []
            },
            'internal_surface': {
                'lateral_movement_paths': 0,
                'privileged_accounts': 0,
                'unencrypted_data': 0
            },
            'supply_chain_surface': {
                'third_party_services': 0,
                'outdated_dependencies': 0
            },
            'total_attack_vectors': 0
        }
        
        # Analizar superficie externa
        for vuln in self.vulnerabilities:
            if vuln.type == VulnerabilityType.EXPOSURE:
                attack_surface['external_surface']['exposed_services'] += len(vuln.affected_resources)
                
                # Contar IPs públicas únicas
                for resource in vuln.affected_resources:
                    if 'public_ips' in resource.get('details', {}):
                        attack_surface['external_surface']['public_ips'] += len(
                            resource['details']['public_ips']
                        )
        
        # Analizar superficie interna
        auth_vulns = [v for v in self.vulnerabilities 
                      if v.type in [VulnerabilityType.AUTHENTICATION, VulnerabilityType.AUTHORIZATION]]
        attack_surface['internal_surface']['privileged_accounts'] = len(auth_vulns)
        
        crypto_vulns = [v for v in self.vulnerabilities if v.type == VulnerabilityType.ENCRYPTION]
        attack_surface['internal_surface']['unencrypted_data'] = len(crypto_vulns)
        
        # Calcular total de vectores de ataque
        attack_surface['total_attack_vectors'] = (
            attack_surface['external_surface']['exposed_services'] +
            attack_surface['internal_surface']['privileged_accounts'] +
            attack_surface['internal_surface']['unencrypted_data']
        )
        
        return attack_surface
    
    def _analyze_remediation_complexity(self) -> Dict[str, Any]:
        """Analizar complejidad de remediación"""
        complexity = {
            'simple_fixes': [],  # < 8 horas
            'moderate_fixes': [],  # 8-40 horas
            'complex_fixes': [],  # > 40 horas
            'total_effort_hours': 0,
            'estimated_timeline': '',
            'resource_requirements': {}
        }
        
        total_hours = 0
        
        for vuln in self.vulnerabilities:
            effort = vuln.remediation.get('effort_hours', 0)
            total_hours += effort
            
            fix_info = {
                'vuln_id': vuln.id,
                'title': vuln.title,
                'effort_hours': effort,
                'priority': vuln.remediation.get('priority', 'MEDIUM')
            }
            
            if effort < 8:
                complexity['simple_fixes'].append(fix_info)
            elif effort <= 40:
                complexity['moderate_fixes'].append(fix_info)
            else:
                complexity['complex_fixes'].append(fix_info)
        
        complexity['total_effort_hours'] = total_hours
        
        # Estimar timeline (asumiendo 2 personas trabajando en paralelo)
        working_hours_per_day = 8
        people = 2
        days_needed = total_hours / (working_hours_per_day * people)
        complexity['estimated_timeline'] = f"{int(days_needed)} días hábiles con {people} personas"
        
        # Recursos requeridos
        complexity['resource_requirements'] = {
            'security_engineers': 2,
            'cloud_architects': 1,
            'estimated_cost': f"${total_hours * 100:,} USD"  # $100/hora promedio
        }
        
        return complexity
    
    def _generate_patch_priority(self) -> List[Dict]:
        """Generar lista priorizada de parches"""
        patch_list = []
        
        for vuln in self.vulnerabilities:
            # Calcular score de prioridad
            priority_score = self._calculate_patch_priority(vuln)
            
            patch_list.append({
                'vuln_id': vuln.id,
                'title': vuln.title,
                'severity': vuln.severity,
                'cvss_score': vuln.cvss_score,
                'priority_score': priority_score,
                'effort_hours': vuln.remediation.get('effort_hours', 0),
                'quick_win': vuln.remediation.get('effort_hours', 0) < 8,
                'dependencies': self._identify_patch_dependencies(vuln),
                'recommended_order': 0  # Se asignará después
            })
        
        # Ordenar por priority_score
        patch_list.sort(key=lambda x: x['priority_score'], reverse=True)
        
        # Asignar orden recomendado
        for i, patch in enumerate(patch_list):
            patch['recommended_order'] = i + 1
        
        return patch_list[:20]  # Top 20 parches prioritarios
    
    def _calculate_patch_priority(self, vuln) -> float:
        """Calcular prioridad de parcheo"""
        # Base score = CVSS
        priority = vuln.cvss_score
        
        # Ajustes por factores
        if vuln.severity == 'CRITICAL':
            priority *= 1.5
        
        # Quick wins obtienen boost
        if vuln.remediation.get('effort_hours', 0) < 8:
            priority *= 1.3
        
        # Vulnerabilidades expuestas a Internet
        if vuln.type == VulnerabilityType.EXPOSURE:
            priority *= 1.4
        
        # Con exploits conocidos
        if len(vuln.cve_ids) > 0:
            priority *= 1.2
        
        return round(priority, 2)
    
    def _identify_patch_dependencies(self, vuln) -> List[str]:
        """Identificar dependencias de parcheo"""
        dependencies = []
        
        # Ejemplos de dependencias comunes
        if 'cifrado' in vuln.title.lower():
            dependencies.append("Implementar KMS primero")
        
        if 'network' in vuln.type.value.lower():
            dependencies.append("Ventana de mantenimiento requerida")
        
        if vuln.type == VulnerabilityType.AUTHENTICATION:
            dependencies.append("Coordinar con todos los usuarios")
        
        return dependencies
    
    def _analyze_security_debt(self) -> Dict[str, Any]:
        """Analizar deuda técnica de seguridad"""
        security_debt = {
            'total_debt_hours': 0,
            'debt_by_age': {
                'immediate': 0,  # Vulnerabilidades que deberían haberse corregido hace tiempo
                'short_term': 0,  # Acumuladas en últimos 3 meses
                'long_term': 0   # Más de 3 meses
            },
            'debt_cost_estimate': 0,
            'interest_rate': 0,  # Costo adicional por no remediar a tiempo
            'projected_cost_if_exploited': 0
        }
        
        # Calcular deuda total
        for vuln in self.vulnerabilities:
            hours = vuln.remediation.get('effort_hours', 0)
            security_debt['total_debt_hours'] += hours
            
            # Clasificar por antigüedad (simulado)
            if vuln.severity == 'CRITICAL':
                security_debt['debt_by_age']['immediate'] += hours
            elif vuln.severity == 'HIGH':
                security_debt['debt_by_age']['short_term'] += hours
            else:
                security_debt['debt_by_age']['long_term'] += hours
        
        # Costo estimado
        hourly_rate = 100  # USD
        security_debt['debt_cost_estimate'] = security_debt['total_debt_hours'] * hourly_rate
        
        # Interés (costo adicional por demora)
        security_debt['interest_rate'] = 0.1  # 10% adicional por mes de demora
        
        # Costo proyectado si se explotan
        avg_breach_cost = 50000  # USD por incidente
        exploit_probability = 0.3  # 30% de probabilidad en 12 meses
        security_debt['projected_cost_if_exploited'] = int(
            len([v for v in self.vulnerabilities if v.severity in ['CRITICAL', 'HIGH']]) *
            avg_breach_cost * exploit_probability
        )
        
        return security_debt
    
    def generate_vulnerability_report(self) -> Dict[str, Any]:
        """Generar reporte ejecutivo de vulnerabilidades"""
        return {
            'executive_summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'critical_count': len([v for v in self.vulnerabilities if v.severity == 'CRITICAL']),
                'high_count': len([v for v in self.vulnerabilities if v.severity == 'HIGH']),
                'average_cvss': round(np.mean([v.cvss_score for v in self.vulnerabilities]), 1) if self.vulnerabilities else 0,
                'most_common_type': self._get_most_common_vulnerability_type(),
                'immediate_actions_required': self._get_immediate_remediation_actions()
            },
            'technical_summary': {
                'vulnerability_distribution': self._get_vulnerability_distribution(),
                'affected_services': self._get_affected_services(),
                'compliance_impact': self._assess_compliance_impact()
            },
            'remediation_roadmap': self._generate_remediation_roadmap()
        }
    
    def _get_most_common_vulnerability_type(self) -> str:
        """Obtener el tipo de vulnerabilidad más común"""
        type_counts = {}
        for vuln in self.vulnerabilities:
            vuln_type = vuln.type.value
            type_counts[vuln_type] = type_counts.get(vuln_type, 0) + 1
        
        if type_counts:
            return max(type_counts.items(), key=lambda x: x[1])[0]
        return "No determinado"
    
    def _get_immediate_remediation_actions(self) -> List[str]:
        """Obtener acciones de remediación inmediatas"""
        actions = []
        
        # Top 3 vulnerabilidades críticas
        critical_vulns = [v for v in self.vulnerabilities if v.severity == 'CRITICAL']
        for vuln in critical_vulns[:3]:
            if vuln.remediation.get('steps'):
                actions.append(f"{vuln.title}: {vuln.remediation['steps'][0]}")
        
        return actions
    
    def _get_vulnerability_distribution(self) -> Dict[str, int]:
        """Obtener distribución de vulnerabilidades"""
        distribution = {}
        for vuln in self.vulnerabilities:
            key = f"{vuln.type.value}_{vuln.severity}"
            distribution[key] = distribution.get(key, 0) + 1
        return distribution
    
    def _get_affected_services(self) -> List[str]:
        """Obtener lista de servicios afectados"""
        services = set()
        for vuln in self.vulnerabilities:
            for resource in vuln.affected_resources:
                services.add(resource.get('type', 'unknown'))
        return list(services)
    
    def _assess_compliance_impact(self) -> Dict[str, List[str]]:
        """Evaluar impacto en cumplimiento normativo"""
        compliance_impact = {
            'pci_dss': [],
            'iso_27001': [],
            'gdpr': [],
            'hipaa': []
        }
        
        for vuln in self.vulnerabilities:
            # PCI DSS
            if vuln.type in [VulnerabilityType.ENCRYPTION, VulnerabilityType.AUTHENTICATION]:
                compliance_impact['pci_dss'].append(vuln.id)
            
            # ISO 27001
            if vuln.type in [VulnerabilityType.ACCESS_CONTROL, VulnerabilityType.MONITORING]:
                compliance_impact['iso_27001'].append(vuln.id)
            
            # GDPR
            if vuln.type in [VulnerabilityType.ENCRYPTION, VulnerabilityType.EXPOSURE]:
                compliance_impact['gdpr'].append(vuln.id)
        
        return compliance_impact
    
    def _generate_remediation_roadmap(self) -> Dict[str, List[Dict]]:
        """Generar roadmap de remediación"""
        roadmap = {
            'phase_1_immediate': [],  # 0-7 días
            'phase_2_short_term': [],  # 7-30 días
            'phase_3_medium_term': []  # 30-90 días
        }
        
        # Ordenar vulnerabilidades por prioridad
        sorted_vulns = sorted(self.vulnerabilities, 
                            key=lambda v: (v.cvss_score, v.remediation.get('effort_hours', 999)), 
                            reverse=True)
        
        for vuln in sorted_vulns:
            roadmap_item = {
                'vuln_id': vuln.id,
                'title': vuln.title,
                'effort_hours': vuln.remediation.get('effort_hours', 0),
                'priority': vuln.remediation.get('priority', 'MEDIUM')
            }
            
            if vuln.severity == 'CRITICAL' or (vuln.severity == 'HIGH' and vuln.remediation.get('effort_hours', 0) < 8):
                roadmap['phase_1_immediate'].append(roadmap_item)
            elif vuln.severity == 'HIGH' or (vuln.severity == 'MEDIUM' and vuln.remediation.get('effort_hours', 0) < 20):
                roadmap['phase_2_short_term'].append(roadmap_item)
            else:
                roadmap['phase_3_medium_term'].append(roadmap_item)
        
        return roadmap


# Función auxiliar para calcular score CVSS
def calculate_cvss_score(finding: Dict) -> float:
    """Calcular score CVSS aproximado basado en características del hallazgo"""
    # Implementación simplificada de CVSS v3.1
    base_score = 5.0
    
    # Ajustar por severidad
    severity_scores = {
        'CRITICAL': 9.0,
        'HIGH': 7.5,
        'MEDIUM': 5.0,
        'LOW': 3.0
    }
    
    base_score = severity_scores.get(finding.get('severity', 'MEDIUM'), 5.0)
    
    # Ajustes adicionales
    if 'internet' in str(finding).lower() or '0.0.0.0/0' in str(finding):
        base_score = min(base_score + 1.5, 10.0)
    
    if 'admin' in str(finding).lower() or 'root' in str(finding).lower():
        base_score = min(base_score + 1.0, 10.0)
    
    if 'no authentication' in str(finding).lower() or 'sin mfa' in str(finding).lower():
        base_score = min(base_score + 0.5, 10.0)
    
    return round(base_score, 1)