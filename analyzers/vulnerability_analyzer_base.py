#!/usr/bin/env python3
"""
Analizador de vulnerabilidades - Clases base y estructuras
"""

import re
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import hashlib

from utils.logger import SecurityLogger
from config.constants import (
    CRITICAL_PORTS, WEAK_CIPHERS, INSECURE_PROTOCOLS,
    MIN_KEY_SIZES, PASSWORD_POLICY
)

class VulnerabilityType(Enum):
    """Tipos de vulnerabilidades"""
    CONFIGURATION = "Configuración Insegura"
    ACCESS_CONTROL = "Control de Acceso Débil"
    ENCRYPTION = "Cifrado Inadecuado"
    AUTHENTICATION = "Autenticación Débil"
    AUTHORIZATION = "Autorización Inadecuada"
    EXPOSURE = "Exposición de Información"
    OUTDATED = "Software Desactualizado"
    MONITORING = "Monitoreo Insuficiente"
    BACKUP = "Respaldo Inadecuado"
    COMPLIANCE = "Incumplimiento Normativo"

@dataclass
class Vulnerability:
    """Clase para representar una vulnerabilidad"""
    id: str
    title: str
    description: str
    type: VulnerabilityType
    severity: str
    cvss_score: float
    cve_ids: List[str]
    affected_resources: List[Dict[str, Any]]
    evidence: Dict[str, Any]
    remediation: Dict[str, Any]
    references: List[str]
    discovered_date: datetime
    false_positive_likelihood: float = 0.0
    
    def to_dict(self) -> Dict:
        """Convertir a diccionario"""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'type': self.type.value,
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'cve_ids': self.cve_ids,
            'affected_resources': self.affected_resources,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'references': self.references,
            'discovered_date': self.discovered_date.isoformat(),
            'false_positive_likelihood': self.false_positive_likelihood
        }

class VulnerabilityAnalyzerBase:
    """Clase base del analizador de vulnerabilidades"""
    
    def __init__(self):
        self.logger = SecurityLogger('VulnerabilityAnalyzer')
        self.vulnerabilities = []
        self.vulnerability_db = self._load_vulnerability_database()
        
    def _load_vulnerability_database(self) -> Dict:
        """Cargar base de datos de vulnerabilidades conocidas"""
        return {
            'weak_passwords': {
                'pattern': r'(password|admin|123456|default)',
                'cvss': 7.5,
                'type': VulnerabilityType.AUTHENTICATION
            },
            'exposed_services': {
                'ports': CRITICAL_PORTS,
                'cvss': 8.5,
                'type': VulnerabilityType.EXPOSURE
            },
            'missing_encryption': {
                'cvss': 6.5,
                'type': VulnerabilityType.ENCRYPTION
            },
            'outdated_tls': {
                'protocols': ['TLSv1.0', 'TLSv1.1', 'SSLv2', 'SSLv3'],
                'cvss': 5.3,
                'type': VulnerabilityType.ENCRYPTION
            }
        }
    
    def _generate_vuln_id(self, category: str, suffix: str) -> str:
        """Generar ID único para vulnerabilidad"""
        timestamp = datetime.now().strftime('%Y%m%d')
        hash_input = f"{category}{suffix}{timestamp}"
        hash_suffix = hashlib.md5(hash_input.encode()).hexdigest()[:6].upper()
        return f"VULN-{category}-{hash_suffix}"
    
    def _find_related_cves(self, exposed_ports: List[Dict]) -> List[str]:
        """Buscar CVEs relacionados con los puertos expuestos"""
        cve_mapping = {
            22: ['CVE-2018-15473', 'CVE-2016-10012'],  # SSH
            3389: ['CVE-2019-0708', 'CVE-2019-1181'],  # RDP (BlueKeep)
            445: ['CVE-2017-0144', 'CVE-2017-0145'],   # SMB (EternalBlue)
            1433: ['CVE-2018-8320'],                    # SQL Server
            3306: ['CVE-2016-6662'],                    # MySQL
            5432: ['CVE-2019-10211'],                   # PostgreSQL
            27017: ['CVE-2019-2108']                    # MongoDB
        }
        
        cves = []
        for port_info in exposed_ports:
            port = port_info.get('port', 0)
            if port in cve_mapping:
                cves.extend(cve_mapping[port])
        
        return list(set(cves))  # Eliminar duplicados
    
    def _check_password_policy_issues(self, policy: Dict) -> List[str]:
        """Verificar problemas en política de contraseñas"""
        issues = []
        
        if policy.get('minimum_length', 0) < PASSWORD_POLICY['min_length']:
            issues.append(f"Longitud mínima insuficiente ({policy.get('minimum_length', 0)} < {PASSWORD_POLICY['min_length']})")
        
        if not policy.get('require_uppercase', False):
            issues.append("No requiere mayúsculas")
        
        if not policy.get('require_lowercase', False):
            issues.append("No requiere minúsculas")
        
        if not policy.get('require_numbers', False):
            issues.append("No requiere números")
        
        if not policy.get('require_special', False):
            issues.append("No requiere caracteres especiales")
        
        validity = policy.get('password_validity_period', 0)
        if validity == 0 or validity > PASSWORD_POLICY['max_age_days']:
            issues.append(f"Período de validez inadecuado ({validity} días)")
        
        return issues
    
    def _check_permissive_rules(self, security_group: Dict) -> List[Dict]:
        """Verificar reglas excesivamente permisivas en security group"""
        permissive_rules = []
        
        for rule in security_group.get('rules', []):
            if rule.get('direction') == 'ingress':
                # Verificar source demasiado amplio
                if rule.get('remote_ip_prefix') in ['0.0.0.0/0', '::/0']:
                    # Verificar si es puerto sensible
                    port_min = rule.get('port_range_min', 0)
                    port_max = rule.get('port_range_max', 65535)
                    
                    if port_min == 0 and port_max == 65535:
                        permissive_rules.append({
                            'rule_id': rule['id'],
                            'issue': 'Permite todo el tráfico desde Internet',
                            'severity': 'CRITICAL'
                        })
                    elif any(port in range(port_min, port_max + 1) for port in CRITICAL_PORTS):
                        permissive_rules.append({
                            'rule_id': rule['id'],
                            'issue': f'Puerto crítico expuesto a Internet ({port_min}-{port_max})',
                            'severity': 'HIGH'
                        })
        
        return permissive_rules