#!/usr/bin/env python3
"""
Clase base para analizadores de vulnerabilidades
Proporciona funcionalidad común para todos los módulos de análisis
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional
import hashlib
import json
from pathlib import Path
import pandas as pd
import numpy as np


class VulnerabilityType(Enum):
    """Tipos de vulnerabilidades"""
    CONFIGURATION = "configuration"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    ENCRYPTION = "encryption"
    LOGGING = "logging"
    NETWORK = "network"
    DATA_EXPOSURE = "data_exposure"
    COMPLIANCE = "compliance"
    OPERATIONAL = "operational"
    MONITORING = "monitoring"


class Severity(Enum):
    """Niveles de severidad basados en CVSS"""
    CRITICAL = "CRITICAL"  # 9.0-10.0
    HIGH = "HIGH"          # 7.0-8.9
    MEDIUM = "MEDIUM"      # 4.0-6.9
    LOW = "LOW"            # 0.1-3.9


@dataclass
class Vulnerability:
    """Estructura de datos para vulnerabilidades"""
    id: str
    code: str  # Código del CSV (ej: IAM-001, NET-003)
    title: str
    description: str
    type: VulnerabilityType
    severity: str
    cvss_score: float
    cve_ids: List[str] = field(default_factory=list)
    affected_resources: List[Dict] = field(default_factory=list)
    evidence: Dict = field(default_factory=dict)
    remediation: Dict = field(default_factory=dict)
    references: List[str] = field(default_factory=list)
    discovered_date: datetime = field(default_factory=datetime.now)
    frameworks: Dict = field(default_factory=dict)  # CIS, ISO, NIST mappings

    def to_dict(self) -> Dict:
        """Convertir la vulnerabilidad a diccionario para serialización"""
        import pandas as pd
        import numpy as np
        
        def clean_value(value):
            """Limpiar valores NaN para JSON"""
            if pd.isna(value) if hasattr(pd, 'isna') else False:
                return None
            if isinstance(value, float) and np.isnan(value) if hasattr(np, 'isnan') else False:
                return None
            if str(value).lower() == 'nan':
                return None
            return value
        
        def clean_list(lst):
            """Limpiar lista de valores NaN"""
            if not isinstance(lst, list):
                return lst
            return [clean_value(item) for item in lst if clean_value(item) is not None]
        
        def clean_dict(d):
            """Limpiar diccionario de valores NaN"""
            if not isinstance(d, dict):
                return d
            return {k: clean_value(v) for k, v in d.items() if clean_value(v) is not None}
        
        return {
            'id': self.id,
            'code': self.code,
            'title': self.title,
            'description': self.description,
            'type': self.type.value if isinstance(self.type, VulnerabilityType) else str(self.type),
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'cve_ids': clean_list(self.cve_ids),
            'affected_resources': self.affected_resources,
            'evidence': clean_dict(self.evidence),
            'remediation': clean_dict(self.remediation),
            'references': clean_list(self.references),
            'discovered_date': self.discovered_date.isoformat() if isinstance(self.discovered_date, datetime) else str(self.discovered_date),
            'frameworks': clean_dict(self.frameworks)
        }


class VulnerabilityAnalyzerBase(ABC):
    """Clase base para analizadores de vulnerabilidades"""

    def __init__(self, logger=None):
        self.vulnerabilities: List[Vulnerability] = []
        self.logger = logger or self._get_default_logger()
        self.security_references = self._load_security_references()

    def _get_default_logger(self):
        """Crear logger por defecto"""
        import logging
        logging.basicConfig(level=logging.INFO)
        return logging.getLogger(self.__class__.__name__)

    def _clean_nan_values(self, value):
        """Limpiar valores NaN de pandas/numpy"""
        if pd.isna(value) or (isinstance(value, float) and np.isnan(value)):
            return None
        return value

    def _load_security_references(self) -> Dict:
        """Cargar referencias de seguridad del CSV"""
        try:
            import pandas as pd
            import numpy as np
            
            # Obtener la ruta absoluta del archivo CSV
            base_dir = Path(__file__).parent.parent
            csv_path = base_dir / 'utils' / 'security_references.csv'

            # Verificar que el archivo existe
            if not csv_path.exists():
                self.logger.warning(
                    f"Archivo CSV no encontrado en: {csv_path}")
                # Crear diccionario vacío si no existe el archivo
                return {}

            # Cargar CSV y reemplazar NaN con None
            df = pd.read_csv(csv_path)
            df = df.fillna('')  # Reemplazar NaN con strings vacíos

            # Convertir a diccionario indexado por código
            references = {}
            for _, row in df.iterrows():
                references[row['Codigo']] = {
                    'dominio': str(row['Dominio']) if pd.notna(row['Dominio']) else '',
                    'control': str(row['Control']) if pd.notna(row['Control']) else '',
                    'descripcion': str(row['Descripcion']) if pd.notna(row['Descripcion']) else '',
                    'severidad': str(row['Severidad']) if pd.notna(row['Severidad']) else 'MEDIUM',
                    'cvss_score': float(row['CVSS_Score']) if pd.notna(row['CVSS_Score']) else 5.0,
                    'framework_cis': str(row['Framework_CIS']) if pd.notna(row['Framework_CIS']) else '',
                    'framework_iso': str(row['Framework_ISO']) if pd.notna(row['Framework_ISO']) else '',
                    'framework_nist': str(row['Framework_NIST']) if pd.notna(row['Framework_NIST']) else '',
                    'tiempo_remediacion_dias': int(row['Tiempo_Remediacion_Dias']) if pd.notna(row['Tiempo_Remediacion_Dias']) else 30,
                    'esfuerzo_horas': int(row['Esfuerzo_Horas']) if pd.notna(row['Esfuerzo_Horas']) else 8,
                    'recomendacion': str(row['Recomendacion']) if pd.notna(row['Recomendacion']) else ''
                }
            return references
        except Exception as e:
            self.logger.warning(
                f"No se pudo cargar security_references.csv: {e}")
            return {}

    def _get_reference_data(self, code: str) -> Dict:
        """Obtener datos de referencia para un código específico"""
        return self.security_references.get(code, {})

    def _generate_vuln_id(self, domain: str, vuln_type: str) -> str:
        """Generar ID único para vulnerabilidad"""
        timestamp = datetime.now().isoformat()
        hash_input = f"{domain}_{vuln_type}_{timestamp}"
        return hashlib.md5(hash_input.encode()).hexdigest()[:12]

    def _create_vulnerability(self, code: str, **kwargs) -> Vulnerability:
        """Crear vulnerabilidad usando datos del CSV y parámetros adicionales"""
        ref_data = self._get_reference_data(code)

        # Función helper para limpiar valores
        def clean_value(value, default=''):
            if pd.isna(value) or value is None or str(value).lower() == 'nan':
                return default
            return str(value) if value != '' else default

        # Combinar datos del CSV con parámetros adicionales
        vuln_data = {
            'id': self._generate_vuln_id(ref_data.get('dominio', 'UNKNOWN'), code),
            'code': code,
            'title': ref_data.get('control', kwargs.get('title', 'Unknown')),
            'description': ref_data.get('descripcion', kwargs.get('description', '')),
            'severity': ref_data.get('severidad', kwargs.get('severity', 'MEDIUM')),
            'cvss_score': ref_data.get('cvss_score', kwargs.get('cvss_score', 5.0)),
            'type': kwargs.get('type', VulnerabilityType.CONFIGURATION),
            'affected_resources': kwargs.get('affected_resources', []),
            'evidence': kwargs.get('evidence', {}),
            'remediation': {
                'steps': kwargs.get('remediation_steps', [ref_data.get('recomendacion', '')]),
                'effort_hours': ref_data.get('esfuerzo_horas', kwargs.get('effort_hours', 8)),
                'priority': ref_data.get('severidad', 'MEDIUM'),
                'time_days': ref_data.get('tiempo_remediacion_dias', 30)
            },
            'references': [
                clean_value(ref_data.get('framework_cis', '')),
                clean_value(ref_data.get('framework_iso', '')),
                clean_value(ref_data.get('framework_nist', ''))
            ],
            'frameworks': {
                'CIS': clean_value(ref_data.get('framework_cis', '')),
                'ISO': clean_value(ref_data.get('framework_iso', '')),
                'NIST': clean_value(ref_data.get('framework_nist', ''))
            },
            'discovered_date': datetime.now()
        }

        # Limpiar referencias vacías
        vuln_data['references'] = [r for r in vuln_data['references'] if r and r.strip()]

        return Vulnerability(**vuln_data)

    def add_vulnerability(self, code: str, **kwargs):
        """Agregar vulnerabilidad a la lista"""
        vuln = self._create_vulnerability(code, **kwargs)
        self.vulnerabilities.append(vuln)
        self.logger.info(f"Vulnerabilidad agregada: {code} - {vuln.title}")

    def _is_policy_overly_permissive(self, policy: Dict) -> bool:
        """Verificar si una política es demasiado permisiva"""
        if not policy:
            return False

        # Verificar si tiene acciones con wildcard
        statements = policy.get('statements', [])
        for statement in statements:
            actions = statement.get('actions', [])
            if any('*' in action for action in actions):
                return True

            # Verificar recursos con wildcard
            resources = statement.get('resources', [])
            if any(resource == '*' for resource in resources):
                return True

        return False

    def _check_password_policy_strength(self, policy: Dict) -> str:
        """Evaluar la fortaleza de la política de contraseñas"""
        if not policy:
            return 'WEAK'

        strength_score = 0

        # Criterios de evaluación
        if policy.get('minimum_password_length', 0) >= 14:
            strength_score += 2
        elif policy.get('minimum_password_length', 0) >= 8:
            strength_score += 1

        if policy.get('require_lowercase_characters'):
            strength_score += 1
        if policy.get('require_uppercase_characters'):
            strength_score += 1
        if policy.get('require_numbers'):
            strength_score += 1
        if policy.get('require_symbols'):
            strength_score += 1
        if policy.get('password_reuse_prevention', 0) >= 5:
            strength_score += 1
        if policy.get('max_password_age', 90) <= 90:
            strength_score += 1

        # Determinar nivel
        if strength_score >= 7:
            return 'STRONG'
        elif strength_score >= 4:
            return 'MEDIUM'
        else:
            return 'WEAK'

    def get_summary(self) -> Dict:
        """Obtener resumen de vulnerabilidades"""
        summary = {
            'total': len(self.vulnerabilities),
            'by_severity': {
                'CRITICAL': 0,
                'HIGH': 0,
                'MEDIUM': 0,
                'LOW': 0
            },
            'by_type': {},
            'by_code': {}
        }

        for vuln in self.vulnerabilities:
            # Por severidad
            summary['by_severity'][vuln.severity] = summary['by_severity'].get(
                vuln.severity, 0) + 1

            # Por tipo
            type_name = vuln.type.value if isinstance(
                vuln.type, VulnerabilityType) else str(vuln.type)
            summary['by_type'][type_name] = summary['by_type'].get(
                type_name, 0) + 1

            # Por código
            summary['by_code'][vuln.code] = vuln.title

        return summary

    def export_vulnerabilities(self) -> List[Dict]:
        """Exportar vulnerabilidades en formato JSON"""
        return [
            {
                'id': vuln.id,
                'code': vuln.code,
                'title': vuln.title,
                'description': vuln.description,
                'type': vuln.type.value if isinstance(vuln.type, VulnerabilityType) else str(vuln.type),
                'severity': vuln.severity,
                'cvss_score': vuln.cvss_score,
                'cve_ids': vuln.cve_ids,
                'affected_resources': vuln.affected_resources,
                'evidence': vuln.evidence,
                'remediation': vuln.remediation,
                'references': vuln.references,
                'frameworks': vuln.frameworks,
                'discovered_date': vuln.discovered_date.isoformat()
            }
            for vuln in self.vulnerabilities
        ]

    @abstractmethod
    def analyze(self, data: Dict) -> List[Vulnerability]:
        """Método abstracto que cada analyzer debe implementar"""
        pass

    def get_vulnerabilities(self) -> List:
        """Obtener lista de vulnerabilidades encontradas"""
        return self.vulnerabilities

    def get_vulnerabilities_by_severity(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por severidad"""
        by_severity = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}

        for vulnerability in self.vulnerabilities:
            severity = vulnerability.severity.upper() if hasattr(
                vulnerability, 'severity') else 'LOW'

            # Normalizar severidades a inglés para consistencia
            if severity in ['CRITICAL', 'CRITICA']:
                by_severity['CRITICAL'] += 1
            elif severity in ['HIGH', 'ALTA']:
                by_severity['HIGH'] += 1
            elif severity in ['MEDIUM', 'MEDIA']:
                by_severity['MEDIUM'] += 1
            else:
                by_severity['LOW'] += 1

        return by_severity

    def get_vulnerabilities_by_type(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por tipo"""
        by_type = {}

        for vulnerability in self.vulnerabilities:
            vuln_type = vulnerability.type.value if hasattr(
                vulnerability, 'type') else 'unknown'
            by_type[vuln_type] = by_type.get(vuln_type, 0) + 1

        return by_type
