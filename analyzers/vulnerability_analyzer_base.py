#!/usr/bin/env python3
"""
Clase base para analizadores de vulnerabilidades
Proporciona funcionalidad común para todos los módulos de análisis
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional
import hashlib
import json
from pathlib import Path


class VulnerabilityType(Enum):
    """Tipos de vulnerabilidades"""
    CONFIGURATION = "configuration"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    ENCRYPTION = "encryption"
    LOGGING = "logging"
    NETWORK = "network"
    DATA_EXPOSURE = "data_exposure"
    COMPLIANCE = "compliance"
    OPERATIONAL = "operational"


class Severity(Enum):
    """Niveles de severidad basados en CVSS"""
    CRITICAL = "CRITICAL"  # 9.0-10.0
    HIGH = "HIGH"          # 7.0-8.9
    MEDIUM = "MEDIUM"      # 4.0-6.9
    LOW = "LOW"            # 0.1-3.9


@dataclass
class Vulnerability:
    """Estructura de datos para vulnerabilidades"""
    id: str
    code: str  # Código del CSV (ej: IAM-001, NET-003)
    title: str
    description: str
    type: VulnerabilityType
    severity: str
    cvss_score: float
    cve_ids: List[str] = field(default_factory=list)
    affected_resources: List[Dict] = field(default_factory=list)
    evidence: Dict = field(default_factory=dict)
    remediation: Dict = field(default_factory=dict)
    references: List[str] = field(default_factory=list)
    discovered_date: datetime = field(default_factory=datetime.now)
    frameworks: Dict = field(default_factory=dict)  # CIS, ISO, NIST mappings


class VulnerabilityAnalyzerBase(ABC):
    """Clase base para analizadores de vulnerabilidades"""

    def __init__(self, logger=None):
        self.vulnerabilities: List[Vulnerability] = []
        self.logger = logger or self._get_default_logger()
        self.security_references = self._load_security_references()

    def _get_default_logger(self):
        """Crear logger por defecto"""
        import logging
        logging.basicConfig(level=logging.INFO)
        return logging.getLogger(self.__class__.__name__)

    def _load_security_references(self) -> Dict:
        """Cargar referencias de seguridad del CSV"""
        try:
            import pandas as pd
            # Obtener la ruta absoluta del archivo CSV
            base_dir = Path(__file__).parent.parent
            csv_path = base_dir / 'utils' / 'security_references.csv'
            
            # Verificar que el archivo existe
            if not csv_path.exists():
                self.logger.warning(f"Archivo CSV no encontrado en: {csv_path}")
                # Crear diccionario vacío si no existe el archivo
                return {}
            
            df = pd.read_csv(csv_path)

            # Convertir a diccionario indexado por código
            references = {}
            for _, row in df.iterrows():
                references[row['Codigo']] = {
                    'dominio': row['Dominio'],
                    'control': row['Control'],
                    'descripcion': row['Descripcion'],
                    'severidad': row['Severidad'],
                    'cvss_score': row['CVSS_Score'],
                    'framework_cis': row['Framework_CIS'],
                    'framework_iso': row['Framework_ISO'],
                    'framework_nist': row['Framework_NIST'],
                    'tiempo_remediacion_dias': row['Tiempo_Remediacion_Dias'],
                    'esfuerzo_horas': row['Esfuerzo_Horas'],
                    'recomendacion': row['Recomendacion']
                }
            return references
        except Exception as e:
            self.logger.warning(
                f"No se pudo cargar security_references.csv: {e}")
            return {}

    def _get_reference_data(self, code: str) -> Dict:
        """Obtener datos de referencia para un código específico"""
        return self.security_references.get(code, {})

    def _generate_vuln_id(self, domain: str, vuln_type: str) -> str:
        """Generar ID único para vulnerabilidad"""
        timestamp = datetime.now().isoformat()
        hash_input = f"{domain}_{vuln_type}_{timestamp}"
        return hashlib.md5(hash_input.encode()).hexdigest()[:12]

    def _create_vulnerability(self, code: str, **kwargs) -> Vulnerability:
        """Crear vulnerabilidad usando datos del CSV y parámetros adicionales"""
        ref_data = self._get_reference_data(code)

        # Combinar datos del CSV con parámetros adicionales
        vuln_data = {
            'id': self._generate_vuln_id(ref_data.get('dominio', 'UNKNOWN'), code),
            'code': code,
            'title': ref_data.get('control', kwargs.get('title', 'Unknown')),
            'description': ref_data.get('descripcion', kwargs.get('description', '')),
            'severity': ref_data.get('severidad', kwargs.get('severity', 'MEDIUM')),
            'cvss_score': ref_data.get('cvss_score', kwargs.get('cvss_score', 5.0)),
            'type': kwargs.get('type', VulnerabilityType.CONFIGURATION),
            'affected_resources': kwargs.get('affected_resources', []),
            'evidence': kwargs.get('evidence', {}),
            'remediation': {
                'steps': kwargs.get('remediation_steps', [ref_data.get('recomendacion', '')]),
                'effort_hours': ref_data.get('esfuerzo_horas', kwargs.get('effort_hours', 8)),
                'priority': ref_data.get('severidad', 'MEDIUM'),
                'time_days': ref_data.get('tiempo_remediacion_dias', 30)
            },
            'references': [
                ref_data.get('framework_cis', ''),
                ref_data.get('framework_iso', ''),
                ref_data.get('framework_nist', '')
            ],
            'frameworks': {
                'CIS': ref_data.get('framework_cis', ''),
                'ISO': ref_data.get('framework_iso', ''),
                'NIST': ref_data.get('framework_nist', '')
            },
            'discovered_date': datetime.now()
        }

        # Limpiar referencias vacías
        vuln_data['references'] = [r for r in vuln_data['references'] if r]

        return Vulnerability(**vuln_data)

    def add_vulnerability(self, code: str, **kwargs):
        """Agregar vulnerabilidad a la lista"""
        vuln = self._create_vulnerability(code, **kwargs)
        self.vulnerabilities.append(vuln)
        self.logger.info(f"Vulnerabilidad agregada: {code} - {vuln.title}")

    def _is_policy_overly_permissive(self, policy: Dict) -> bool:
        """Verificar si una política es demasiado permisiva"""
        if not policy:
            return False

        # Verificar si tiene acciones con wildcard
        statements = policy.get('statements', [])
        for statement in statements:
            actions = statement.get('actions', [])
            if any('*' in action for action in actions):
                return True

            # Verificar recursos con wildcard
            resources = statement.get('resources', [])
            if any(resource == '*' for resource in resources):
                return True

        return False

    def _check_password_policy_strength(self, policy: Dict) -> str:
        """Evaluar la fortaleza de la política de contraseñas"""
        if not policy:
            return 'WEAK'

        strength_score = 0

        # Criterios de evaluación
        if policy.get('minimum_password_length', 0) >= 14:
            strength_score += 2
        elif policy.get('minimum_password_length', 0) >= 8:
            strength_score += 1

        if policy.get('require_lowercase_characters'):
            strength_score += 1
        if policy.get('require_uppercase_characters'):
            strength_score += 1
        if policy.get('require_numbers'):
            strength_score += 1
        if policy.get('require_symbols'):
            strength_score += 1
        if policy.get('password_reuse_prevention', 0) >= 5:
            strength_score += 1
        if policy.get('max_password_age', 90) <= 90:
            strength_score += 1

        # Determinar nivel
        if strength_score >= 7:
            return 'STRONG'
        elif strength_score >= 4:
            return 'MEDIUM'
        else:
            return 'WEAK'

    def get_summary(self) -> Dict:
        """Obtener resumen de vulnerabilidades"""
        summary = {
            'total': len(self.vulnerabilities),
            'by_severity': {
                'CRITICAL': 0,
                'HIGH': 0,
                'MEDIUM': 0,
                'LOW': 0
            },
            'by_type': {},
            'by_code': {}
        }

        for vuln in self.vulnerabilities:
            # Por severidad
            summary['by_severity'][vuln.severity] = summary['by_severity'].get(
                vuln.severity, 0) + 1

            # Por tipo
            type_name = vuln.type.value if isinstance(
                vuln.type, VulnerabilityType) else str(vuln.type)
            summary['by_type'][type_name] = summary['by_type'].get(
                type_name, 0) + 1

            # Por código
            summary['by_code'][vuln.code] = vuln.title

        return summary

    def export_vulnerabilities(self) -> List[Dict]:
        """Exportar vulnerabilidades en formato JSON"""
        return [
            {
                'id': vuln.id,
                'code': vuln.code,
                'title': vuln.title,
                'description': vuln.description,
                'type': vuln.type.value if isinstance(vuln.type, VulnerabilityType) else str(vuln.type),
                'severity': vuln.severity,
                'cvss_score': vuln.cvss_score,
                'cve_ids': vuln.cve_ids,
                'affected_resources': vuln.affected_resources,
                'evidence': vuln.evidence,
                'remediation': vuln.remediation,
                'references': vuln.references,
                'frameworks': vuln.frameworks,
                'discovered_date': vuln.discovered_date.isoformat()
            }
            for vuln in self.vulnerabilities
        ]

    @abstractmethod
    def analyze(self, data: Dict) -> List[Vulnerability]:
        """Método abstracto que cada analyzer debe implementar"""
        pass

    def get_vulnerabilities(self) -> List:
        """Obtener lista de vulnerabilidades encontradas"""
        return self.vulnerabilities

    def get_vulnerabilities_by_severity(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por severidad"""
        by_severity = {'CRITICA': 0, 'ALTA': 0, 'MEDIA': 0, 'BAJA': 0}
        
        for vulnerability in self.vulnerabilities:
            severity = vulnerability.severity.upper() if hasattr(vulnerability, 'severity') else 'BAJA'
            
            # Mapear severidades
            if severity in ['CRITICAL', 'CRITICA']:
                by_severity['CRITICA'] += 1
            elif severity in ['HIGH', 'ALTA']:
                by_severity['ALTA'] += 1
            elif severity in ['MEDIUM', 'MEDIA']:
                by_severity['MEDIA'] += 1
            else:
                by_severity['BAJA'] += 1
        
        return by_severity

    def get_vulnerabilities_by_type(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por tipo"""
        by_type = {}
        
        for vulnerability in self.vulnerabilities:
            vuln_type = vulnerability.type.value if hasattr(vulnerability, 'type') else 'unknown'
            by_type[vuln_type] = by_type.get(vuln_type, 0) + 1
        
        return by_type
