#!/usr/bin/env python3
"""
Analizador de vulnerabilidades - Módulos Storage, Monitoring y Cross-module
"""

from datetime import datetime
from typing import Dict, List, Any

from .vulnerability_analyzer_base import (
    VulnerabilityAnalyzerBase, Vulnerability, VulnerabilityType
)
from config.constants import LOG_RETENTION_REQUIREMENTS

class StorageMonitoringVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Analizador de vulnerabilidades para módulos Storage, Monitoring y análisis cross-module"""
    
    def analyze_storage_vulnerabilities(self, storage_data: Dict):
        """Analizar vulnerabilidades de almacenamiento"""
        self.logger.info("Analizando vulnerabilidades de almacenamiento")
        
        # Volúmenes sin cifrar
        unencrypted_volumes = []
        for region, volumes in storage_data.get('evs_volumes', {}).items():
            for volume in volumes:
                if not volume.get('encrypted', False):
                    unencrypted_volumes.append({
                        'id': volume['id'],
                        'name': volume['name'],
                        'size': volume['size'],
                        'region': region,
                        'attachments': len(volume.get('attachments', []))
                    })
        
        if unencrypted_volumes:
            total_size_gb = sum(v['size'] for v in unencrypted_volumes)
            
            vuln = Vulnerability(
                id=self._generate_vuln_id('STO', 'UNCRYPT-EVS'),
                title="Volúmenes de almacenamiento sin cifrado at-rest",
                description=f"{len(unencrypted_volumes)} volúmenes EVS sin cifrar, totalizando {total_size_gb}GB de datos potencialmente expuestos",
                type=VulnerabilityType.ENCRYPTION,
                severity="HIGH",
                cvss_score=7.1,
                cve_ids=[],
                affected_resources=[{
                    'type': 'evs_volume',
                    'identifiers': [v['id'] for v in unencrypted_volumes],
                    'details': unencrypted_volumes
                }],
                evidence={
                    'unencrypted_count': len(unencrypted_volumes),
                    'total_size_gb': total_size_gb,
                    'sample_volumes': unencrypted_volumes[:5]
                },
                remediation={
                    'steps': [
                        "Crear snapshots de volúmenes existentes",
                        "Crear nuevos volúmenes con cifrado habilitado",
                        "Migrar datos a volúmenes cifrados",
                        "Implementar KMS para gestión de claves",
                        "Establecer política de cifrado obligatorio"
                    ],
                    'effort_hours': 40,
                    'priority': 'HIGH'
                },
                references=[
                    "CIS Control 13.1",
                    "PCI DSS 3.4",
                    "HIPAA § 164.312(a)(2)(iv)"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Buckets OBS públicos
        public_buckets = []
        for bucket in storage_data.get('obs_buckets', []):
            if bucket.get('public_access', False):
                public_buckets.append({
                    'name': bucket['name'],
                    'size_bytes': bucket.get('size_bytes', 0),
                    'object_count': bucket.get('object_count', 0),
                    'has_encryption': bucket.get('encryption', {}).get('enabled', False)
                })
        
        if public_buckets:
            vuln = Vulnerability(
                id=self._generate_vuln_id('STO', 'PUBLIC-OBS'),
                title="Buckets de almacenamiento con acceso público",
                description=f"{len(public_buckets)} buckets OBS accesibles públicamente, exponiendo potencialmente datos sensibles",
                type=VulnerabilityType.EXPOSURE,
                severity="CRITICAL",
                cvss_score=8.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'obs_bucket',
                    'identifiers': [b['name'] for b in public_buckets],
                    'details': public_buckets
                }],
                evidence={
                    'public_buckets': public_buckets,
                    'total_exposed_objects': sum(b['object_count'] for b in public_buckets)
                },
                remediation={
                    'steps': [
                        "Auditar contenido de buckets públicos",
                        "Cambiar ACL a privado para todos los buckets",
                        "Implementar políticas de bucket restrictivas",
                        "Usar CloudFront/CDN para contenido que debe ser público",
                        "Habilitar logging de acceso a buckets"
                    ],
                    'effort_hours': 16,
                    'priority': 'CRITICAL'
                },
                references=[
                    "OWASP Cloud Top 10 - C3",
                    "AWS S3 Security Best Practices"
                ],
                discovered_date=datetime.now(),
                false_positive_likelihood=0.1
            )
            self.vulnerabilities.append(vuln)
        
        # Verificar configuración de backups
        self._check_backup_configuration(storage_data)
        
        # Verificar versionado de buckets
        self._check_bucket_versioning(storage_data)
        
        # Verificar clasificación de datos
        self._check_data_classification(storage_data)
    
    def analyze_monitoring_vulnerabilities(self, monitoring_data: Dict):
        """Analizar vulnerabilidades de monitoreo y logging"""
        self.logger.info("Analizando vulnerabilidades de monitoreo")
        
        # Cloud Trace no configurado
        cts_config = monitoring_data.get('cloud_trace', {})
        if not cts_config.get('trackers', []):
            vuln = Vulnerability(
                id=self._generate_vuln_id('MON', 'NO-CTS'),
                title="Auditoría de eventos no configurada",
                description="Cloud Trace Service no está habilitado, imposibilitando la auditoría de actividades",
                type=VulnerabilityType.MONITORING,
                severity="HIGH",
                cvss_score=7.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'account_service',
                    'identifiers': ['cloud_trace_service']
                }],
                evidence={
                    'cts_enabled': False,
                    'trackers_count': 0
                },
                remediation={
                    'steps': [
                        "Habilitar Cloud Trace Service inmediatamente",
                        "Configurar tracker para todas las regiones",
                        "Establecer retención mínima de 365 días",
                        "Habilitar cifrado de logs",
                        "Configurar alertas para eventos críticos"
                    ],
                    'effort_hours': 8,
                    'priority': 'HIGH'
                },
                references=[
                    "CIS Control 6.2",
                    "ISO 27001:2022 A.12.4"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Retención insuficiente de logs
        insufficient_retention = []
        for region, lts_data in monitoring_data.get('log_tank', {}).items():
            for log_group in lts_data.get('log_groups', []):
                if log_group.get('ttl_in_days', 0) < 90:
                    insufficient_retention.append({
                        'log_group': log_group['log_group_name'],
                        'current_retention': log_group.get('ttl_in_days', 0),
                        'region': region
                    })
        
        if insufficient_retention:
            vuln = Vulnerability(
                id=self._generate_vuln_id('MON', 'LOG-RETENTION'),
                title="Período de retención de logs insuficiente",
                description=f"{len(insufficient_retention)} grupos de logs con retención menor a 90 días",
                type=VulnerabilityType.COMPLIANCE,
                severity="MEDIUM",
                cvss_score=5.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'log_group',
                    'identifiers': [lg['log_group'] for lg in insufficient_retention],
                    'details': insufficient_retention
                }],
                evidence={
                    'insufficient_groups': insufficient_retention,
                    'min_retention_found': min(lg['current_retention'] for lg in insufficient_retention)
                },
                remediation={
                    'steps': [
                        "Actualizar política de retención a mínimo 90 días",
                        "Para logs de seguridad, establecer 365 días",
                        "Implementar archivo a largo plazo en OBS",
                        "Configurar lifecycle policies para optimizar costos"
                    ],
                    'effort_hours': 6,
                    'priority': 'MEDIUM'
                },
                references=[
                    "PCI DSS 10.7",
                    "GDPR Article 5(1)(e)"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Verificar configuración de alarmas
        self._check_alarm_configuration(monitoring_data)
        
        # Verificar cobertura de monitoreo
        self._check_monitoring_coverage(monitoring_data)
    
    def analyze_cross_module_vulnerabilities(self, modules: Dict):
        """Analizar vulnerabilidades que cruzan múltiples módulos"""
        self.logger.info("Analizando vulnerabilidades cross-module")
        
        # Falta de segregación de ambientes
        if self._detect_environment_mixing(modules):
            vuln = Vulnerability(
                id=self._generate_vuln_id('CROSS', 'ENV-MIX'),
                title="Falta de segregación entre ambientes de producción y no-producción",
                description="Recursos de diferentes ambientes comparten la misma infraestructura de red",
                type=VulnerabilityType.CONFIGURATION,
                severity="HIGH",
                cvss_score=7.8,
                cve_ids=[],
                affected_resources=[{
                    'type': 'multiple',
                    'identifiers': ['network_architecture'],
                    'details': {'finding': 'Producción y desarrollo en misma VPC'}
                }],
                evidence={
                    'mixed_resources': True,
                    'security_impact': 'Alto riesgo de movimiento lateral'
                },
                remediation={
                    'steps': [
                        "Crear VPCs separadas para cada ambiente",
                        "Implementar cuentas separadas si es posible",
                        "Establecer políticas de comunicación inter-VPC",
                        "Usar diferentes rangos CIDR por ambiente"
                    ],
                    'effort_hours': 80,
                    'priority': 'HIGH'
                },
                references=[
                    "NIST SP 800-53 SC-32",
                    "Cloud Security Alliance CCM v4"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Falta de defensa en profundidad
        defense_gaps = self._analyze_defense_in_depth(modules)
        if defense_gaps:
            vuln = Vulnerability(
                id=self._generate_vuln_id('CROSS', 'DEF-DEPTH'),
                title="Implementación incompleta de defensa en profundidad",
                description="Múltiples capas de seguridad faltantes o mal configuradas",
                type=VulnerabilityType.CONFIGURATION,
                severity="HIGH",
                cvss_score=7.2,
                cve_ids=[],
                affected_resources=[{
                    'type': 'architecture',
                    'identifiers': ['security_architecture'],
                    'details': defense_gaps
                }],
                evidence={
                    'missing_layers': defense_gaps,
                    'coverage_percentage': self._calculate_defense_coverage(modules)
                },
                remediation={
                    'steps': [
                        "Implementar WAF para aplicaciones web",
                        "Desplegar IDS/IPS en puntos críticos",
                        "Habilitar HSS en todos los servidores",
                        "Configurar DDoS protection",
                        "Implementar segmentación de red granular"
                    ],
                    'effort_hours': 120,
                    'priority': 'HIGH'
                },
                references=[
                    "NIST SP 800-190",
                    "Defense in Depth Strategy"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Verificar consistencia de configuración entre regiones
        self._check_cross_region_consistency(modules)
    
    def _check_backup_configuration(self, storage_data: Dict):
        """Verificar configuración de backups"""
        resources_without_backup = []
        
        # Verificar volúmenes críticos sin backup
        for region, volumes in storage_data.get('evs_volumes', {}).items():
            for volume in volumes:
                if self._is_critical_volume(volume) and not self._has_backup_configured(volume):
                    resources_without_backup.append({
                        'resource_id': volume['id'],
                        'resource_name': volume['name'],
                        'resource_type': 'EVS',
                        'region': region
                    })
        
        if resources_without_backup:
            vuln = Vulnerability(
                id=self._generate_vuln_id('STO', 'NO-BACKUP'),
                title="Recursos críticos sin estrategia de backup",
                description=f"{len(resources_without_backup)} recursos críticos sin backup configurado",
                type=VulnerabilityType.BACKUP,
                severity="HIGH",
                cvss_score=7.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'multiple',
                    'identifiers': [r['resource_id'] for r in resources_without_backup],
                    'details': resources_without_backup
                }],
                evidence={
                    'resources_without_backup': resources_without_backup,
                    'total_count': len(resources_without_backup)
                },
                remediation={
                    'steps': [
                        "Implementar política de backup automático",
                        "Configurar snapshots diarios para recursos críticos",
                        "Establecer retención según criticidad",
                        "Probar restauración periódicamente",
                        "Considerar replicación cross-region"
                    ],
                    'effort_hours': 32,
                    'priority': 'HIGH'
                },
                references=[
                    "NIST SP 800-34",
                    "ISO 27001:2022 A.12.3"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_bucket_versioning(self, storage_data: Dict):
        """Verificar versionado de buckets"""
        buckets_without_versioning = []
        
        for bucket in storage_data.get('obs_buckets', []):
            if self._is_critical_bucket(bucket) and bucket.get('versioning') != 'Enabled':
                buckets_without_versioning.append({
                    'bucket_name': bucket['name'],
                    'size_bytes': bucket.get('size_bytes', 0),
                    'object_count': bucket.get('object_count', 0)
                })
        
        if buckets_without_versioning:
            vuln = Vulnerability(
                id=self._generate_vuln_id('STO', 'NO-VERSION'),
                title="Buckets críticos sin versionado habilitado",
                description=f"{len(buckets_without_versioning)} buckets importantes sin control de versiones",
                type=VulnerabilityType.CONFIGURATION,
                severity="MEDIUM",
                cvss_score=5.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'obs_bucket',
                    'identifiers': [b['bucket_name'] for b in buckets_without_versioning],
                    'details': buckets_without_versioning
                }],
                evidence={
                    'buckets': buckets_without_versioning,
                    'total_count': len(buckets_without_versioning)
                },
                remediation={
                    'steps': [
                        "Habilitar versionado en buckets críticos",
                        "Configurar política de lifecycle para versiones antiguas",
                        "Implementar protección contra borrado accidental",
                        "Establecer permisos granulares para modificación"
                    ],
                    'effort_hours': 8,
                    'priority': 'MEDIUM'
                },
                references=[
                    "Storage Best Practices",
                    "Data Protection Guidelines"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_data_classification(self, storage_data: Dict):
        """Verificar clasificación de datos"""
        unclassified_resources = []
        
        # Verificar volúmenes sin clasificación
        for region, volumes in storage_data.get('evs_volumes', {}).items():
            for volume in volumes:
                if not self._has_classification_tag(volume.get('tags', {})):
                    unclassified_resources.append({
                        'resource_type': 'EVS',
                        'resource_id': volume['id'],
                        'resource_name': volume['name'],
                        'size_gb': volume.get('size', 0)
                    })
        
        # Verificar buckets sin clasificación
        for bucket in storage_data.get('obs_buckets', []):
            if not self._has_classification_tag(bucket.get('tags', {})):
                unclassified_resources.append({
                    'resource_type': 'OBS',
                    'resource_id': bucket['name'],
                    'resource_name': bucket['name'],
                    'size_gb': round(bucket.get('size_bytes', 0) / (1024**3), 2)
                })
        
        if unclassified_resources:
            vuln = Vulnerability(
                id=self._generate_vuln_id('STO', 'NO-CLASS'),
                title="Recursos de almacenamiento sin clasificación de datos",
                description=f"{len(unclassified_resources)} recursos sin etiquetas de clasificación de datos",
                type=VulnerabilityType.COMPLIANCE,
                severity="LOW",
                cvss_score=3.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'multiple',
                    'identifiers': [r['resource_id'] for r in unclassified_resources],
                    'details': unclassified_resources
                }],
                evidence={
                    'unclassified_count': len(unclassified_resources),
                    'sample_resources': unclassified_resources[:5]
                },
                remediation={
                    'steps': [
                        "Implementar esquema de clasificación de datos",
                        "Etiquetar recursos según sensibilidad (Público/Interno/Confidencial/Secreto)",
                        "Aplicar controles según clasificación",
                        "Automatizar etiquetado en creación de recursos"
                    ],
                    'effort_hours': 24,
                    'priority': 'LOW'
                },
                references=[
                    "ISO 27001:2022 A.8.2",
                    "Data Classification Policy"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_alarm_configuration(self, monitoring_data: Dict):
        """Verificar configuración de alarmas"""
        missing_alarms = []
        
        # Verificar alarmas críticas faltantes
        required_alarms = [
            'cpu_utilization_high',
            'memory_utilization_high',
            'disk_utilization_high',
            'unauthorized_api_calls',
            'root_account_usage',
            'security_group_changes'
        ]
        
        configured_alarms = set()
        for region, alarms in monitoring_data.get('alarms', {}).items():
            for alarm in alarms:
                configured_alarms.add(alarm.get('metric_name', '').lower())
        
        for required in required_alarms:
            if required not in configured_alarms:
                missing_alarms.append(required)
        
        if missing_alarms:
            vuln = Vulnerability(
                id=self._generate_vuln_id('MON', 'NO-ALARMS'),
                title="Alarmas críticas no configuradas",
                description=f"{len(missing_alarms)} alarmas críticas faltantes para detección de incidentes",
                type=VulnerabilityType.MONITORING,
                severity="MEDIUM",
                cvss_score=6.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'monitoring_config',
                    'identifiers': ['cloud_eye_alarms'],
                    'details': {'missing_alarms': missing_alarms}
                }],
                evidence={
                    'missing_alarms': missing_alarms,
                    'total_configured': len(configured_alarms)
                },
                remediation={
                    'steps': [
                        "Configurar alarmas para métricas críticas",
                        "Establecer umbrales apropiados",
                        "Configurar notificaciones a equipo de seguridad",
                        "Probar alarmas periódicamente"
                    ],
                    'effort_hours': 16,
                    'priority': 'MEDIUM'
                },
                references=[
                    "Cloud Monitoring Best Practices",
                    "NIST SI-4"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_monitoring_coverage(self, monitoring_data: Dict):
        """Verificar cobertura de monitoreo"""
        low_coverage_services = []
        
        coverage_data = monitoring_data.get('metrics_coverage', {})
        for region, coverage in coverage_data.items():
            for service, metrics in coverage.items():
                if metrics.get('percentage', 0) < 80:
                    low_coverage_services.append({
                        'service': service,
                        'region': region,
                        'coverage_percentage': metrics.get('percentage', 0),
                        'monitored': metrics.get('monitored', 0),
                        'total': metrics.get('total', 0)
                    })
        
        if low_coverage_services:
            vuln = Vulnerability(
                id=self._generate_vuln_id('MON', 'LOW-COV'),
                title="Cobertura insuficiente de monitoreo",
                description=f"{len(low_coverage_services)} servicios con menos del 80% de cobertura de monitoreo",
                type=VulnerabilityType.MONITORING,
                severity="MEDIUM",
                cvss_score=5.8,
                cve_ids=[],
                affected_resources=[{
                    'type': 'multiple_services',
                    'identifiers': [f"{s['service']}_{s['region']}" for s in low_coverage_services],
                    'details': low_coverage_services
                }],
                evidence={
                    'low_coverage_services': low_coverage_services,
                    'average_coverage': sum(s['coverage_percentage'] for s in low_coverage_services) / len(low_coverage_services)
                },
                remediation={
                    'steps': [
                        "Habilitar métricas detalladas para todos los servicios",
                        "Configurar agentes de monitoreo donde sea necesario",
                        "Implementar custom metrics para aplicaciones",
                        "Integrar con plataforma SIEM"
                    ],
                    'effort_hours': 40,
                    'priority': 'MEDIUM'
                },
                references=[
                    "Observability Best Practices",
                    "CIS Control 6"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _detect_environment_mixing(self, modules: Dict) -> bool:
        """Detectar mezcla de ambientes"""
        prod_indicators = ['prod', 'production', 'prd']
        dev_indicators = ['dev', 'development', 'test', 'qa', 'staging']
        
        vpcs = []
        for region_vpcs in modules.get('network', {}).get('vpcs', {}).values():
            vpcs.extend(region_vpcs)
        
        has_prod = False
        has_dev = False
        
        for vpc in vpcs:
            vpc_name = vpc.get('name', '').lower()
            if any(ind in vpc_name for ind in prod_indicators):
                has_prod = True
            if any(ind in vpc_name for ind in dev_indicators):
                has_dev = True
        
        # Si hay VPCs de ambos tipos, verificar si están aisladas
        return has_prod and has_dev
    
    def _analyze_defense_in_depth(self, modules: Dict) -> List[str]:
        """Analizar brechas en defensa en profundidad"""
        gaps = []
        
        # Verificar WAF
        waf_configured = self._check_waf_configuration(modules)
        if not waf_configured:
            gaps.append("WAF no configurado para aplicaciones web")
        
        # Verificar HSS/EDR
        hss_coverage = self._calculate_hss_coverage(modules)
        if hss_coverage < 0.8:
            gaps.append(f"Protección de endpoints insuficiente (HSS: {hss_coverage*100:.0f}%)")
        
        # Verificar segmentación de red
        vpcs = modules.get('network', {}).get('vpcs', {})
        total_vpcs = sum(len(vpc_list) for vpc_list in vpcs.values())
        if total_vpcs < 2:
            gaps.append("Segmentación de red insuficiente")
        
        # Verificar DDoS protection
        ddos_enabled = self._check_ddos_protection(modules)
        if not ddos_enabled:
            gaps.append("Protección DDoS no habilitada")
        
        # Verificar IDS/IPS
        ids_configured = self._check_ids_configuration(modules)
        if not ids_configured:
            gaps.append("Sistema de detección de intrusiones no configurado")
        
        return gaps
    
    def _calculate_defense_coverage(self, modules: Dict) -> float:
        """Calcular porcentaje de cobertura de defensa en profundidad"""
        total_controls = 10
        implemented = 0
        
        # Verificar controles implementados
        if modules.get('monitoring', {}).get('cloud_trace', {}).get('trackers'):
            implemented += 1
        
        if modules.get('network', {}).get('security_groups'):
            implemented += 1
        
        # Verificar cifrado
        storage = modules.get('storage', {})
        if storage.get('encryption_status', {}).get('overall', 0) > 80:
            implemented += 1
        
        # Verificar MFA
        iam = modules.get('iam', {})
        if iam.get('mfa_status', {}).get('mfa_enabled', 0) > 0.8 * iam.get('mfa_status', {}).get('total_users', 1):
            implemented += 1
        
        # Verificar backups
        if modules.get('storage', {}).get('backups'):
            implemented += 1
        
        # Verificar alarmas
        if modules.get('monitoring', {}).get('alarms'):
            implemented += 1
        
        return (implemented / total_controls) * 100
    
    def _check_cross_region_consistency(self, modules: Dict):
        """Verificar consistencia de configuración entre regiones"""
        inconsistencies = []
        
        # Comparar configuraciones de seguridad entre regiones
        network_data = modules.get('network', {})
        regions = list(network_data.get('vpcs', {}).keys())
        
        if len(regions) > 1:
            # Comparar número de security groups por región
            sg_counts = {}
            for region in regions:
                sg_counts[region] = len(network_data.get('security_groups', {}).get(region, []))
            
            # Si hay diferencias significativas
            max_sgs = max(sg_counts.values()) if sg_counts else 0
            min_sgs = min(sg_counts.values()) if sg_counts else 0
            
            if max_sgs > 0 and (max_sgs - min_sgs) / max_sgs > 0.5:
                inconsistencies.append({
                    'type': 'security_groups',
                    'issue': 'Diferencia significativa en número de security groups entre regiones',
                    'details': sg_counts
                })
        
        if inconsistencies:
            vuln = Vulnerability(
                id=self._generate_vuln_id('CROSS', 'INCONSIST'),
                title="Inconsistencias de configuración entre regiones",
                description="Configuraciones de seguridad no uniformes entre diferentes regiones",
                type=VulnerabilityType.CONFIGURATION,
                severity="MEDIUM",
                cvss_score=5.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'multi_region',
                    'identifiers': regions,
                    'details': inconsistencies
                }],
                evidence={
                    'inconsistencies': inconsistencies,
                    'regions_analyzed': len(regions)
                },
                remediation={
                    'steps': [
                        "Estandarizar configuraciones de seguridad entre regiones",
                        "Implementar Infrastructure as Code",
                        "Usar templates para despliegues consistentes",
                        "Establecer proceso de revisión cross-region"
                    ],
                    'effort_hours': 24,
                    'priority': 'MEDIUM'
                },
                references=[
                    "Multi-region Best Practices",
                    "Configuration Management"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    # Métodos auxiliares
    def _is_critical_volume(self, volume: Dict) -> bool:
        """Determinar si un volumen es crítico"""
        critical_indicators = ['database', 'db', 'prod', 'critical', 'backup']
        volume_name = volume.get('name', '').lower()
        return any(indicator in volume_name for indicator in critical_indicators)
    
    def _has_backup_configured(self, volume: Dict) -> bool:
        """Verificar si un volumen tiene backup configurado"""
        # Simplificado - en producción verificaría configuración real de CSBS/VBS
        return volume.get('metadata', {}).get('backup_enabled', False)
    
    def _is_critical_bucket(self, bucket: Dict) -> bool:
        """Determinar si un bucket es crítico"""
        critical_keywords = ['backup', 'prod', 'critical', 'database', 'logs', 'audit']
        bucket_name = bucket.get('name', '').lower()
        return any(keyword in bucket_name for keyword in critical_keywords)
    
    def _has_classification_tag(self, tags: Dict) -> bool:
        """Verificar si tiene tag de clasificación"""
        classification_keys = ['Classification', 'DataClassification', 'Clasificacion', 'data-classification']
        return any(key in tags for key in classification_keys)
    
    def _check_waf_configuration(self, modules: Dict) -> bool:
        """Verificar configuración de WAF"""
        # Simplificado - buscaría configuración real de WAF
        return False
    
    def _calculate_hss_coverage(self, modules: Dict) -> float:
        """Calcular cobertura de HSS"""
        # Simplificado - calcularía basado en servidores con HSS instalado
        return 0.0
    
    def _check_ddos_protection(self, modules: Dict) -> bool:
        """Verificar protección DDoS"""
        # Simplificado - verificaría Anti-DDoS Pro
        return False
    
    def _check_ids_configuration(self, modules: Dict) -> bool:
        """Verificar configuración de IDS/IPS"""
        # Simplificado - verificaría configuración real
        return False