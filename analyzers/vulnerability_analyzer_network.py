#!/usr/bin/env python3
"""
Analizador de vulnerabilidades para Network - CORREGIDO para estructura por regiones
"""

from datetime import datetime
from typing import Dict, List, Any, Set
from .vulnerability_analyzer_base import VulnerabilityAnalyzerBase, VulnerabilityType


class NetworkVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Analizador específico para vulnerabilidades de red"""

    # Puertos críticos que no deberían estar expuestos
    CRITICAL_PORTS = {
        22: 'SSH',
        23: 'Telnet',
        135: 'RPC',
        139: 'NetBIOS',
        445: 'SMB',
        1433: 'SQL Server',
        1521: 'Oracle',
        3306: 'MySQL',
        3389: 'RDP',
        5432: 'PostgreSQL',
        5900: 'VNC',
        6379: 'Redis',
        7001: 'Cassandra',
        8020: 'Hadoop',
        9200: 'Elasticsearch',
        11211: 'Memcached',
        27017: 'MongoDB'
    }

    # Puertos de gestión que requieren protección especial
    MANAGEMENT_PORTS = {
        22: 'SSH',
        3389: 'RDP',
        5985: 'WinRM HTTP',
        5986: 'WinRM HTTPS',
        8443: 'HTTPS Management',
        9443: 'Management Console'
    }

    def analyze_network_vulnerabilities(self, network_data: Dict):
        """Método principal de análisis con identificación mejorada"""
        self.logger.info("Iniciando análisis de vulnerabilidades de red")

        try:
            # Verificaciones básicas existentes
            self._check_vpc_segregation_by_region(network_data)
            self._check_public_subnets_by_region(network_data)
            self._check_security_groups_by_region(network_data)
            self._check_exposed_resources(network_data)

            # Verificación de VPC Endpoints
            self._check_vpc_endpoints_coverage(network_data)  # NET-018

            # Nuevas verificaciones mejoradas
            self._check_vpc_empty_resources(network_data)
            self._check_vpc_naming_compliance(network_data)
            self._check_cross_environment_communication(network_data)

            self.logger.info(
                f"Análisis completado. Vulnerabilidades encontradas: {len(self.vulnerabilities)}")
            return self.vulnerabilities

        except Exception as e:
            self.logger.error(f"Error en análisis de red: {e}")
            import traceback
            traceback.print_exc()
            return []

    def _check_vpc_segregation_by_region(self, network_data: Dict):
        """NET-001: Verificar segregación de VPCs por región"""
        vpcs_without_segregation = []

        vpcs_data = network_data.get('vpcs', {})
        subnets_data = network_data.get('subnets', {})

        for region, vpcs in vpcs_data.items():
            region_subnets = subnets_data.get(region, [])

            for vpc in vpcs:
                vpc_id = vpc.get('id')
                vpc_subnets = [
                    s for s in region_subnets if s.get('vpc_id') == vpc_id]

                if len(vpc_subnets) > 1:
                    public_subnets = [
                        s for s in vpc_subnets if s.get('is_public', False)]
                    private_subnets = [
                        s for s in vpc_subnets if not s.get('is_public', False)]

                    if len(public_subnets) == 0 or len(private_subnets) == 0:
                        vpcs_without_segregation.append({
                            'vpc_id': vpc_id,
                            'vpc_name': vpc.get('name', 'Unknown'),
                            'region': region,
                            'total_subnets': len(vpc_subnets),
                            'public_subnets': len(public_subnets),
                            'private_subnets': len(private_subnets)
                        })

        if vpcs_without_segregation:
            self.add_vulnerability(
                code='NET-001',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc',
                    'identifiers': [v['vpc_id'] for v in vpcs_without_segregation]
                }],
                evidence={'vpcs': vpcs_without_segregation}
            )

    def _check_public_subnets_by_region(self, network_data: Dict):
        """NET-002: Verificar subnets públicas sin justificación"""
        unjustified_subnets = []

        subnets_data = network_data.get('subnets', {})

        for region, subnets in subnets_data.items():
            for subnet in subnets:
                if subnet.get('is_public', False):
                    purpose = subnet.get('purpose', 'unknown')
                    if purpose not in ['public', 'dmz']:
                        unjustified_subnets.append({
                            'subnet_id': subnet.get('id'),
                            'subnet_name': subnet.get('name', 'Unknown'),
                            'region': region,
                            'purpose': purpose
                        })

        if unjustified_subnets:
            self.add_vulnerability(
                code='NET-002',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'subnet',
                    'identifiers': [s['subnet_id'] for s in unjustified_subnets]
                }],
                evidence={'subnets': unjustified_subnets}
            )

    def _check_security_groups_by_region(self, network_data: Dict):
        """NET-003: Verificar security groups permisivos"""
        permissive_sgs = []

        sgs_data = network_data.get('security_groups', {})

        for region, sgs in sgs_data.items():
            for sg in sgs:
                if sg.get('has_permissive_rules', False):
                    permissive_sgs.append({
                        'sg_id': sg.get('id'),
                        'sg_name': sg.get('name', 'Unknown'),
                        'region': region,
                        'rules_count': len(sg.get('rules', []))
                    })

        if permissive_sgs:
            self.add_vulnerability(
                code='NET-003',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'security_group',
                    'identifiers': [sg['sg_id'] for sg in permissive_sgs]
                }],
                evidence={'security_groups': permissive_sgs}
            )

    def _check_exposed_resources(self, network_data: Dict):
        """NET-004: Verificar recursos expuestos"""
        exposed_resources = network_data.get('exposed_resources', [])
        critical_exposures = [
            r for r in exposed_resources if r.get('critical_exposure', False)]

        if critical_exposures:
            self.add_vulnerability(
                code='NET-004',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'resource',
                    'identifiers': [r.get('resource_id') for r in critical_exposures]
                }],
                evidence={'exposed_resources': critical_exposures}
            )

    # Método de compatibilidad
    def analyze(self, network_data: Dict):
        return self.analyze_network_vulnerabilities(network_data)

    def _check_public_subnets(self, network_data: Dict):
        """NET-002: Verificar subnets públicas sin justificación"""
        unjustified_public_subnets = []

        # Manejar estructura por regiones
        vpcs_data = network_data.get('vpcs', {})
        subnets_data = network_data.get('subnets', {})

        if isinstance(vpcs_data, dict):
            for region, vpcs in vpcs_data.items():
                if isinstance(vpcs, list):
                    region_subnets = subnets_data.get(
                        region, []) if isinstance(subnets_data, dict) else []

                    for subnet in region_subnets:
                        if subnet.get('is_public', False):
                            # Verificar justificación
                            purpose = subnet.get('purpose', 'unknown')
                            if purpose not in ['public', 'dmz']:
                                unjustified_public_subnets.append({
                                    'subnet_id': subnet.get('id', 'Unknown'),
                                    'subnet_name': subnet.get('name', 'Unknown'),
                                    'vpc_id': subnet.get('vpc_id', 'Unknown'),
                                    'region': region,
                                    'cidr': subnet.get('cidr', 'Unknown')
                                })

        # Generar vulnerabilidad si hay problemas
        if unjustified_public_subnets:
            self.add_vulnerability(
                code='NET-002',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'subnet',
                    'identifiers': [s['subnet_id'] for s in unjustified_public_subnets]
                }],
                evidence={
                    'subnets': unjustified_public_subnets,
                    'total_affected': len(unjustified_public_subnets)
                },
                remediation_steps=[
                    "Revisar y justificar cada subnet pública",
                    "Convertir a privadas las subnets sin recursos públicos",
                    "Documentar la razón de negocio para subnets públicas",
                    "Implementar NAT Gateway para acceso saliente desde subnets privadas"
                ]
            )

    def _check_security_group_rules(self, network_data: Dict):
        """NET-003: Verificar security groups con reglas permisivas"""
        overly_permissive_sgs = []

        # Manejar estructura por regiones
        sgs_data = network_data.get('security_groups', {})

        if isinstance(sgs_data, dict):
            for region, sgs in sgs_data.items():
                if isinstance(sgs, list):
                    for sg in sgs:
                        if sg.get('has_permissive_rules', False):
                            overly_permissive_sgs.append({
                                'sg_id': sg.get('id', 'Unknown'),
                                'sg_name': sg.get('name', 'Unknown'),
                                'region': region,
                                'rules_count': len(sg.get('rules', []))
                            })

        if overly_permissive_sgs:
            self.add_vulnerability(
                code='NET-003',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'security_group',
                    'identifiers': list(set([sg['sg_id'] for sg in overly_permissive_sgs]))
                }],
                evidence={
                    # Limitar a 10 ejemplos
                    'permissive_rules': overly_permissive_sgs[:10],
                    'total_issues': len(overly_permissive_sgs)
                },
                remediation_steps=[
                    "Aplicar principio de menor privilegio en reglas de seguridad",
                    "Restringir acceso solo desde IPs o rangos conocidos",
                    "Usar Security Groups de origen en lugar de IPs cuando sea posible",
                    "Eliminar reglas con protocolo -1 o puerto 0-65535"
                ]
            )

    def _check_exposed_critical_ports(self, network_data: Dict):
        """NET-004: Verificar puertos críticos expuestos"""
        exposed_critical_ports = []

        # Verificar en security groups
        security_groups = network_data.get('security_groups', [])

        for sg in security_groups:
            ingress_rules = sg.get('ingress_rules', [])

            for rule in ingress_rules:
                source = rule.get('source', '')
                from_port = rule.get('from_port', 0)
                to_port = rule.get('to_port', 0)

                # Si la fuente es Internet (0.0.0.0/0)
                if source == '0.0.0.0/0' or source == '::/0':
                    # Verificar cada puerto crítico
                    for critical_port, service in self.CRITICAL_PORTS.items():
                        if from_port <= critical_port <= to_port:
                            exposed_critical_ports.append({
                                'sg_id': sg.get('id', 'Unknown'),
                                'sg_name': sg.get('name', 'Unknown'),
                                'port': critical_port,
                                'service': service,
                                'source': source
                            })

        # Verificar también en instancias con IPs públicas
        instances = network_data.get('instances', [])
        for instance in instances:
            if instance.get('has_public_ip', False):
                open_ports = instance.get('open_ports', [])
                for port in open_ports:
                    if port in self.CRITICAL_PORTS:
                        exposed_critical_ports.append({
                            'instance_id': instance.get('id', 'Unknown'),
                            'instance_name': instance.get('name', 'Unknown'),
                            'port': port,
                            'service': self.CRITICAL_PORTS[port],
                            'public_ip': '{{PUBLIC_IP}}'  # Sanitizado
                        })

        if exposed_critical_ports:
            self.add_vulnerability(
                code='NET-004',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'mixed',
                    'identifiers': list(set([
                        ep.get('sg_id', ep.get('instance_id', 'Unknown'))
                        for ep in exposed_critical_ports
                    ]))
                }],
                evidence={
                    # Limitar ejemplos
                    'exposed_ports': exposed_critical_ports[:15],
                    'total_exposures': len(exposed_critical_ports),
                    'unique_services': list(set([ep['service'] for ep in exposed_critical_ports]))
                },
                remediation_steps=[
                    "Cerrar puertos críticos al acceso desde Internet",
                    "Implementar VPN o bastion hosts para acceso administrativo",
                    "Usar servicios gestionados en lugar de exponer bases de datos",
                    "Implementar listas blancas de IPs para servicios críticos"
                ]
            )

    def _check_network_acls(self, network_data: Dict):
        """NET-005: Verificar ausencia de Network ACLs"""
        subnets_without_nacls = []

        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            subnets = vpc.get('subnets', [])

            for subnet in subnets:
                nacl = subnet.get('network_acl')

                # Verificar si usa NACL por defecto o no tiene NACL personalizada
                if not nacl or nacl.get('is_default', True):
                    subnets_without_nacls.append({
                        'subnet_id': subnet.get('id', 'Unknown'),
                        'subnet_name': subnet.get('name', 'Unknown'),
                        'vpc_id': vpc.get('id', 'Unknown'),
                        'is_public': subnet.get('is_public', False)
                    })

        if subnets_without_nacls:
            # Solo reportar si hay muchas subnets sin NACLs personalizadas
            if len(subnets_without_nacls) > 3:
                self.add_vulnerability(
                    code='NET-005',
                    type=VulnerabilityType.NETWORK,
                    affected_resources=[{
                        'type': 'subnet',
                        'identifiers': [s['subnet_id'] for s in subnets_without_nacls[:10]]
                    }],
                    evidence={
                        'subnets_without_custom_nacls': subnets_without_nacls[:10],
                        'total_affected': len(subnets_without_nacls)
                    },
                    remediation_steps=[
                        "Implementar Network ACLs personalizadas para defensa en profundidad",
                        "Configurar reglas específicas por subnet según su función",
                        "Priorizar NACLs en subnets públicas y DMZ",
                        "Documentar las reglas y su justificación"
                    ]
                )

    def _check_vpc_peering(self, network_data: Dict):
        """NET-006: Verificar VPC Peering sin restricciones"""
        unrestricted_peerings = []

        vpc_peerings = network_data.get('vpc_peerings', [])

        for peering in vpc_peerings:
            # Verificar si tiene restricciones de ruta o seguridad
            routes = peering.get('routes', [])

            # Verificar si permite todo el tráfico
            has_unrestricted_route = False
            for route in routes:
                if route.get('destination_cidr') == '0.0.0.0/0':
                    has_unrestricted_route = True
                    break

            # Verificar si no tiene security groups específicos
            if has_unrestricted_route or not peering.get('has_route_restrictions', True):
                unrestricted_peerings.append({
                    'peering_id': peering.get('id', 'Unknown'),
                    'requester_vpc': peering.get('requester_vpc_id', 'Unknown'),
                    'accepter_vpc': peering.get('accepter_vpc_id', 'Unknown'),
                    'status': peering.get('status', 'Unknown')
                })

        if unrestricted_peerings:
            self.add_vulnerability(
                code='NET-006',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc_peering',
                    'identifiers': [p['peering_id'] for p in unrestricted_peerings]
                }],
                evidence={
                    'unrestricted_peerings': unrestricted_peerings,
                    'total_affected': len(unrestricted_peerings)
                },
                remediation_steps=[
                    "Implementar rutas específicas en VPC peering",
                    "Evitar rutas 0.0.0.0/0 en conexiones peering",
                    "Documentar el propósito de cada conexión peering",
                    "Implementar security groups restrictivos en recursos compartidos"
                ]
            )

    def _check_elb_encryption(self, network_data: Dict):
        """NET-007: Verificar ELB sin cifrado SSL/TLS"""
        unencrypted_elbs = []
        weak_tls_elbs = []

        load_balancers = network_data.get('load_balancers', [])

        for elb in load_balancers:
            elb_id = elb.get('id', 'Unknown')
            elb_name = elb.get('name', 'Unknown')

            # Verificar listeners
            listeners = elb.get('listeners', [])

            for listener in listeners:
                protocol = listener.get('protocol', '').upper()
                port = listener.get('port', 0)

                # Verificar si usa HTTP en lugar de HTTPS
                if protocol == 'HTTP' and port in [80, 8080, 8000]:
                    unencrypted_elbs.append({
                        'elb_id': elb_id,
                        'elb_name': elb_name,
                        'listener_port': port,
                        'protocol': protocol
                    })

                # Verificar versión de TLS si usa HTTPS
                if protocol == 'HTTPS':
                    tls_version = listener.get(
                        'ssl_policy', {}).get('min_tls_version', '')
                    if tls_version in ['TLSv1.0', 'TLSv1.1', 'SSLv3']:
                        weak_tls_elbs.append({
                            'elb_id': elb_id,
                            'elb_name': elb_name,
                            'tls_version': tls_version
                        })

        if unencrypted_elbs or weak_tls_elbs:
            evidence = {}
            if unencrypted_elbs:
                evidence['unencrypted_listeners'] = unencrypted_elbs
            if weak_tls_elbs:
                evidence['weak_tls_configs'] = weak_tls_elbs

            self.add_vulnerability(
                code='NET-007',
                type=VulnerabilityType.ENCRYPTION,
                affected_resources=[{
                    'type': 'elb',
                    'identifiers': list(set([
                        e['elb_id'] for e in unencrypted_elbs + weak_tls_elbs
                    ]))
                }],
                evidence=evidence,
                remediation_steps=[
                    "Habilitar HTTPS en todos los ELBs públicos",
                    "Configurar redirección de HTTP a HTTPS",
                    "Usar TLS 1.2 como versión mínima",
                    "Implementar certificados SSL válidos",
                    "Configurar políticas de seguridad SSL recomendadas"
                ]
            )

    def _check_flow_logs(self, network_data: Dict):
        """NET-008: Verificar ausencia de Flow Logs"""
        resources_without_flow_logs = []

        # Verificar VPCs sin flow logs
        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            if not vpc.get('flow_logs_enabled', False):
                resources_without_flow_logs.append({
                    'type': 'vpc',
                    'id': vpc.get('id', 'Unknown'),
                    'name': vpc.get('name', 'Unknown')
                })

        # Verificar subnets críticas sin flow logs
        for vpc in vpcs:
            subnets = vpc.get('subnets', [])
            for subnet in subnets:
                # Solo verificar subnets públicas o con recursos críticos
                if subnet.get('is_public', False) and not subnet.get('flow_logs_enabled', False):
                    resources_without_flow_logs.append({
                        'type': 'subnet',
                        'id': subnet.get('id', 'Unknown'),
                        'name': subnet.get('name', 'Unknown'),
                        'vpc_id': vpc.get('id', 'Unknown')
                    })

        if resources_without_flow_logs:
            self.add_vulnerability(
                code='NET-008',
                type=VulnerabilityType.LOGGING,
                affected_resources=[{
                    'type': 'network_resource',
                    'identifiers': [r['id'] for r in resources_without_flow_logs[:20]]
                }],
                evidence={
                    'resources_without_logs': resources_without_flow_logs[:10],
                    'total_affected': len(resources_without_flow_logs),
                    'vpcs_affected': len([r for r in resources_without_flow_logs if r['type'] == 'vpc']),
                    'subnets_affected': len([r for r in resources_without_flow_logs if r['type'] == 'subnet'])
                },
                remediation_steps=[
                    "Habilitar VPC Flow Logs en todas las VPCs",
                    "Configurar retención adecuada (mínimo 90 días)",
                    "Centralizar logs en servicio de análisis",
                    "Implementar alertas para tráfico anómalo",
                    "Documentar exclusiones si las hay"
                ]
            )

    def _analyze_network_segmentation(self, network_data: Dict) -> Dict:
        """Análisis adicional de segmentación de red"""
        segmentation_issues = {
            'flat_networks': [],
            'missing_dmz': [],
            'cross_environment_connections': []
        }

        vpcs = network_data.get('vpcs', [])

        for vpc in vpcs:
            vpc_name = vpc.get('name', '').lower()
            subnets = vpc.get('subnets', [])

            # Detectar redes planas (sin segmentación)
            subnet_types = set()
            for subnet in subnets:
                if 'public' in subnet.get('name', '').lower():
                    subnet_types.add('public')
                elif 'private' in subnet.get('name', '').lower():
                    subnet_types.add('private')
                elif 'dmz' in subnet.get('name', '').lower():
                    subnet_types.add('dmz')
                elif 'data' in subnet.get('name', '').lower():
                    subnet_types.add('data')

            if len(subnet_types) < 2 and len(subnets) > 2:
                segmentation_issues['flat_networks'].append(vpc.get('id'))

            # Detectar falta de DMZ en VPCs con recursos públicos
            if 'public' in subnet_types and 'dmz' not in subnet_types:
                segmentation_issues['missing_dmz'].append(vpc.get('id'))

            # Detectar conexiones entre ambientes
            if any(env in vpc_name for env in ['prod', 'production']):
                peerings = vpc.get('peering_connections', [])
                for peer in peerings:
                    peer_vpc_name = peer.get('peer_vpc_name', '').lower()
                    if any(env in peer_vpc_name for env in ['dev', 'test', 'qa']):
                        segmentation_issues['cross_environment_connections'].append({
                            'prod_vpc': vpc.get('id'),
                            'non_prod_vpc': peer.get('peer_vpc_id')
                        })

        return segmentation_issues

    def _check_internet_gateways(self, network_data: Dict):
        """Verificación adicional de Internet Gateways"""
        igw_issues = []

        internet_gateways = network_data.get('internet_gateways', [])

        for igw in internet_gateways:
            attached_vpcs = igw.get('attached_vpcs', [])

            # Verificar IGWs attached a múltiples VPCs (no debería ser posible, pero verificar)
            if len(attached_vpcs) > 1:
                igw_issues.append({
                    'igw_id': igw.get('id'),
                    'issue': 'attached_to_multiple_vpcs',
                    'vpc_count': len(attached_vpcs)
                })

            # Verificar IGWs sin uso
            for vpc_id in attached_vpcs:
                vpc_data = next((v for v in network_data.get(
                    'vpcs', []) if v.get('id') == vpc_id), None)
                if vpc_data:
                    has_public_subnet = any(s.get('is_public')
                                            for s in vpc_data.get('subnets', []))
                    if not has_public_subnet:
                        igw_issues.append({
                            'igw_id': igw.get('id'),
                            'issue': 'attached_but_no_public_subnets',
                            'vpc_id': vpc_id
                        })

        return igw_issues

    def _identify_vpc_environment(self, vpc_name: str) -> str:
        """Identificar el ambiente de una VPC por su nombre"""
        if not vpc_name:
            return 'unknown'

        vpc_name_lower = vpc_name.lower()

        # Patrones de producción
        if any(pattern in vpc_name_lower for pattern in [
            'prod', 'production', 'prd', 'live', 'main'
        ]):
            return 'production'

        # Patrones de desarrollo
        elif any(pattern in vpc_name_lower for pattern in [
            'dev', 'development', 'develop', 'devel'
        ]):
            return 'development'

        # Patrones de testing
        elif any(pattern in vpc_name_lower for pattern in [
            'test', 'testing', 'qa', 'quality', 'stage', 'staging', 'uat'
        ]):
            return 'testing'

        # Patrones de sandbox
        elif any(pattern in vpc_name_lower for pattern in [
            'sandbox', 'sb', 'demo', 'trial', 'lab'
        ]):
            return 'sandbox'

        # Patrones de compartido/shared
        elif any(pattern in vpc_name_lower for pattern in [
            'shared', 'common', 'core', 'infra', 'infrastructure'
        ]):
            return 'shared'

        return 'unknown'

    def _identify_vpc_purpose(self, vpc_name: str) -> str:
        """Identificar el propósito de una VPC por su nombre"""
        if not vpc_name:
            return 'unknown'

        vpc_name_lower = vpc_name.lower()

        # Aplicaciones web
        if any(pattern in vpc_name_lower for pattern in [
            'web', 'app', 'application', 'frontend', 'ui'
        ]):
            return 'application'

        # Bases de datos
        elif any(pattern in vpc_name_lower for pattern in [
            'db', 'database', 'data', 'storage', 'rds'
        ]):
            return 'database'

        # Servicios de red
        elif any(pattern in vpc_name_lower for pattern in [
            'network', 'net', 'connectivity', 'transit', 'hub'
        ]):
            return 'network'

        # Monitoreo y logging
        elif any(pattern in vpc_name_lower for pattern in [
            'monitor', 'log', 'observability', 'metric', 'audit'
        ]):
            return 'monitoring'

        # Seguridad
        elif any(pattern in vpc_name_lower for pattern in [
            'security', 'sec', 'firewall', 'waf', 'guard'
        ]):
            return 'security'

        return 'general'

    def _check_vpc_empty_resources(self, network_data: Dict):
        """NET-021: Verificar VPCs sin recursos asociados"""
        empty_vpcs = []

        vpcs_data = network_data.get('vpcs', {})
        subnets_data = network_data.get('subnets', {})

        for region, vpcs in vpcs_data.items():
            region_subnets = subnets_data.get(region, [])

            for vpc in vpcs:
                vpc_id = vpc.get('id')
                vpc_name = vpc.get('name', 'Unknown')

                # Buscar subnets de esta VPC
                vpc_subnets = [
                    s for s in region_subnets if s.get('vpc_id') == vpc_id]

                # Contar recursos en las subnets
                total_instances = 0
                total_resources = 0

                for subnet in vpc_subnets:
                    # Contar instancias/servidores (si están disponibles en los datos)
                    instances = subnet.get('instances', [])
                    total_instances += len(instances)

                    # Otros recursos que podrían estar en la subnet
                    resources = subnet.get('resources', [])
                    total_resources += len(resources)

                # Identificar VPC vacía
                is_empty = (total_instances == 0 and total_resources ==
                            0 and len(vpc_subnets) <= 1)

                # Obtener información adicional de la VPC
                vpc_info = {
                    'vpc_id': vpc_id,
                    'vpc_name': vpc_name,
                    'region': region,
                    'environment': self._identify_vpc_environment(vpc_name),
                    'purpose': self._identify_vpc_purpose(vpc_name),
                    'subnet_count': len(vpc_subnets),
                    'instance_count': total_instances,
                    'resource_count': total_resources,
                    'is_empty': is_empty,
                    'created_at': vpc.get('created_at', 'Unknown'),
                    'cidr': vpc.get('cidr', 'Unknown')
                }

                if is_empty:
                    empty_vpcs.append(vpc_info)

        if empty_vpcs:
            self.add_vulnerability(
                code='NET-021',
                type=VulnerabilityType.OPERATIONAL,
                affected_resources=[{
                    'type': 'vpc',
                    'identifiers': [v['vpc_id'] for v in empty_vpcs]
                }],
                evidence={
                    'empty_vpcs': empty_vpcs,
                    'total_empty': len(empty_vpcs),
                    'environments_affected': list(set([v['environment'] for v in empty_vpcs])),
                    # Estimado $10/mes por VPC vacía
                    'potential_cost_waste': len(empty_vpcs) * 10
                },
                remediation_steps=[
                    "Revisar y eliminar VPCs sin recursos activos",
                    "Documentar el propósito de VPCs aparentemente vacías",
                    "Consolidar recursos en VPCs existentes cuando sea posible",
                    "Establecer proceso de limpieza regular de recursos no utilizados"
                ]
            )

    def _check_vpc_naming_compliance(self, network_data: Dict):
        """NET-022: Verificar cumplimiento de convenciones de nomenclatura"""
        non_compliant_vpcs = []

        vpcs_data = network_data.get('vpcs', {})

        for region, vpcs in vpcs_data.items():
            for vpc in vpcs:
                vpc_name = vpc.get('name', '')
                vpc_id = vpc.get('id')

                issues = []

                # Verificar longitud del nombre
                if len(vpc_name) < 3:
                    issues.append("Nombre muy corto (< 3 caracteres)")
                elif len(vpc_name) > 50:
                    issues.append("Nombre muy largo (> 50 caracteres)")

                # Verificar caracteres especiales
                if not vpc_name.replace('-', '').replace('_', '').isalnum():
                    issues.append("Contiene caracteres no permitidos")

                # Verificar si tiene patrón de ambiente
                environment = self._identify_vpc_environment(vpc_name)
                if environment == 'unknown':
                    issues.append("No indica ambiente (prod/dev/test)")

                # Verificar si usa nombres por defecto
                if vpc_name.lower() in ['default', 'vpc-default', 'main', 'primary']:
                    issues.append("Usa nombre por defecto o genérico")

                # Verificar patrón recomendado: {project}-{env}-{purpose}-vpc
                name_parts = vpc_name.lower().split('-')
                if len(name_parts) < 3:
                    issues.append(
                        "No sigue patrón recomendado: {project}-{env}-{purpose}")

                if issues:
                    non_compliant_vpcs.append({
                        'vpc_id': vpc_id,
                        'vpc_name': vpc_name,
                        'region': region,
                        'environment': environment,
                        'issues': issues,
                        'suggested_pattern': f"project-{environment}-purpose-vpc"
                    })

        if non_compliant_vpcs:
            self.add_vulnerability(
                code='NET-022',
                type=VulnerabilityType.COMPLIANCE,
                affected_resources=[{
                    'type': 'vpc',
                    'identifiers': [v['vpc_id'] for v in non_compliant_vpcs]
                }],
                evidence={
                    # Mostrar hasta 10
                    'non_compliant_vpcs': non_compliant_vpcs[:10],
                    'total_non_compliant': len(non_compliant_vpcs),
                    'common_issues': self._get_common_naming_issues(non_compliant_vpcs)
                },
                remediation_steps=[
                    "Establecer y documentar convenciones de nomenclatura",
                    "Renombrar VPCs para seguir patrón: {project}-{env}-{purpose}-vpc",
                    "Evitar nombres genéricos como 'default' o 'main'",
                    "Incluir indicador de ambiente en todos los nombres",
                    "Implementar validación automática en proceso de creación"
                ]
            )

    def _get_common_naming_issues(self, non_compliant_vpcs: List[Dict]) -> List[Dict]:
        """Obtener estadísticas de problemas comunes de nomenclatura"""
        issue_counts = {}

        for vpc in non_compliant_vpcs:
            for issue in vpc['issues']:
                issue_counts[issue] = issue_counts.get(issue, 0) + 1

        return [
            {'issue': issue, 'count': count, 'percentage': round(
                count/len(non_compliant_vpcs)*100, 1)}
            for issue, count in sorted(issue_counts.items(), key=lambda x: x[1], reverse=True)
        ]

    def _check_cross_environment_communication(self, network_data: Dict):
        """NET-023: Verificar comunicación entre ambientes"""
        cross_env_issues = []

        vpcs_data = network_data.get('vpcs', {})
        peerings_data = network_data.get('vpc_peerings', {})

        # Mapear VPCs por ambiente
        vpc_environments = {}
        for region, vpcs in vpcs_data.items():
            for vpc in vpcs:
                vpc_id = vpc.get('id')
                vpc_name = vpc.get('name', '')
                environment = self._identify_vpc_environment(vpc_name)
                vpc_environments[vpc_id] = {
                    'name': vpc_name,
                    'environment': environment,
                    'region': region
                }

        # Verificar peerings entre ambientes
        for region, peerings in peerings_data.items():
            for peering in peerings:
                local_vpc_id = peering.get('local_vpc_id')
                peer_vpc_id = peering.get('peer_vpc_id')

                local_env = vpc_environments.get(
                    local_vpc_id, {}).get('environment', 'unknown')
                peer_env = vpc_environments.get(
                    peer_vpc_id, {}).get('environment', 'unknown')

                # Detectar comunicación problemática entre ambientes
                problematic_combinations = [
                    ('production', 'development'),
                    ('production', 'testing'),
                    ('production', 'sandbox')
                ]

                if (local_env, peer_env) in problematic_combinations or (peer_env, local_env) in problematic_combinations:
                    cross_env_issues.append({
                        'peering_id': peering.get('id'),
                        'local_vpc': {
                            'id': local_vpc_id,
                            'name': vpc_environments.get(local_vpc_id, {}).get('name', 'Unknown'),
                            'environment': local_env
                        },
                        'peer_vpc': {
                            'id': peer_vpc_id,
                            'name': vpc_environments.get(peer_vpc_id, {}).get('name', 'Unknown'),
                            'environment': peer_env
                        },
                        'region': region,
                        'risk_level': 'HIGH' if local_env == 'production' or peer_env == 'production' else 'MEDIUM'
                    })

        if cross_env_issues:
            self.add_vulnerability(
                code='NET-023',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc_peering',
                    'identifiers': [issue['peering_id'] for issue in cross_env_issues]
                }],
                evidence={
                    'cross_environment_peerings': cross_env_issues,
                    'high_risk_count': len([i for i in cross_env_issues if i['risk_level'] == 'HIGH']),
                    'environments_involved': list(set([i['local_vpc']['environment'] for i in cross_env_issues] +
                                                      [i['peer_vpc']['environment'] for i in cross_env_issues]))
                },
                remediation_steps=[
                    "Eliminar peerings innecesarios entre prod y no-prod",
                    "Implementar transit gateway para comunicación controlada",
                    "Documentar y justificar comunicación cross-environment necesaria",
                    "Aplicar security groups restrictivos en recursos compartidos",
                    "Implementar monitoreo de tráfico entre ambientes"
                ]
            )

    # ===== NUEVOS MÉTODOS DE VERIFICACIÓN (NET-024 a NET-041) =====

    def _check_vpn_redundancy(self, network_data: Dict):
        """NET-024: VPN Site-to-Site sin Redundancia"""
        vpn_without_redundancy = []

        vpn_connections = network_data.get('vpn_connections', {})

        # Agrupar VPNs por peer address para detectar redundancia
        vpn_by_peer = {}
        for region, vpns in vpn_connections.items():
            for vpn in vpns:
                peer_addr = vpn.get('peer_address', 'unknown')
                if peer_addr not in vpn_by_peer:
                    vpn_by_peer[peer_addr] = []
                vpn_by_peer[peer_addr].append(vpn)

        # Identificar VPNs sin redundancia
        for peer_addr, vpns in vpn_by_peer.items():
            if len(vpns) == 1:  # Solo un túnel
                vpn_without_redundancy.extend(vpns)

        if vpn_without_redundancy:
            self.add_vulnerability(
                code='NET-024',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpn_connection',
                    'identifiers': [vpn['id'] for vpn in vpn_without_redundancy]
                }],
                evidence={'vpn_without_redundancy': vpn_without_redundancy}
            )

    def _check_vpn_encryption_algorithms(self, network_data: Dict):
        """NET-025: VPN con Algoritmos Débiles"""
        weak_encryption_vpns = []

        # Algoritmos débiles
        weak_algorithms = {
            'encryption': ['3des', 'des'],
            'authentication': ['md5', 'sha1']
        }

        for region, vpns in network_data.get('vpn_connections', {}).items():
            for vpn in vpns:
                encryption_alg = vpn.get('encryption_algorithm', '').lower()
                auth_alg = vpn.get('authentication_algorithm', '').lower()

                weak_issues = []
                if encryption_alg in weak_algorithms['encryption']:
                    weak_issues.append(f'Cifrado débil: {encryption_alg}')

                if auth_alg in weak_algorithms['authentication']:
                    weak_issues.append(f'Autenticación débil: {auth_alg}')

                if weak_issues:
                    weak_encryption_vpns.append({
                        'vpn_id': vpn['id'],
                        'vpn_name': vpn['name'],
                        'region': region,
                        'weak_algorithms': weak_issues
                    })

        if weak_encryption_vpns:
            self.add_vulnerability(
                code='NET-025',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpn_connection',
                    'identifiers': [vpn['vpn_id'] for vpn in weak_encryption_vpns]
                }],
                evidence={'weak_encryption_vpns': weak_encryption_vpns}
            )

    def _check_elb_health_checks(self, network_data: Dict):
        """NET-032: ELB sin Health Checks Personalizados"""
        elb_basic_health_checks = []

        for region, lbs in network_data.get('load_balancers', {}).items():
            for lb in lbs:
                listeners = lb.get('listeners', [])
                has_custom_health_check = any(
                    listener.get('health_check_type') == 'custom'
                    for listener in listeners
                )

                if not has_custom_health_check and listeners:
                    elb_basic_health_checks.append({
                        'elb_id': lb['id'],
                        'elb_name': lb['name'],
                        'region': region
                    })

        if elb_basic_health_checks:
            self.add_vulnerability(
                code='NET-032',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'load_balancer',
                    'identifiers': [elb['elb_id'] for elb in elb_basic_health_checks]
                }],
                evidence={'elb_basic_health_checks': elb_basic_health_checks}
            )

    def _check_microsegmentation(self, network_data: Dict):
        """NET-040: Network sin Microsegmentación"""
        microsegmentation_issues = []

        # Verificar subnets con muchos recursos
        for region, subnets in network_data.get('subnets', {}).items():
            for subnet in subnets:
                resource_count = subnet.get('resource_count', 0)

                if resource_count > 10:
                    microsegmentation_issues.append({
                        'subnet_id': subnet['id'],
                        'subnet_name': subnet['name'],
                        'resource_count': resource_count,
                        'region': region
                    })

        if microsegmentation_issues:
            self.add_vulnerability(
                code='NET-040',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'subnet',
                    'identifiers': [s['subnet_id'] for s in microsegmentation_issues]
                }],
                evidence={'microsegmentation_issues': microsegmentation_issues}
            )

    def _requires_session_persistence(self, lb: Dict) -> bool:
        """Determinar si un ELB requiere persistencia de sesión"""
        lb_name = lb.get('name', '').lower()
        session_apps = ['app', 'web', 'portal', 'dashboard']
        return any(app in lb_name for app in session_apps)

    def _check_vpc_endpoints_coverage(self, network_data: Dict):
        """NET-018: Sin VPC Endpoints para Servicios"""
        services_without_endpoints = []
        total_missing = 0

        # Servicios críticos que deberían tener VPC Endpoints
        critical_services = ['OBS', 'RDS', 'DDS',
                             'ECS', 'EVS', 'KMS', 'DNS', 'SMN']

        # Analizar por región
        for region in network_data.get('vpcs', {}).keys():
            vpc_endpoints = network_data.get(
                'vpc_endpoints', {}).get(region, [])

            # Verificar qué servicios tienen endpoints
            services_with_endpoints = set()
            for endpoint in vpc_endpoints:
                service_name = endpoint.get('service_name', '')
                if service_name in critical_services:
                    services_with_endpoints.add(service_name)

            # Identificar servicios sin endpoints
            missing_services = [
                s for s in critical_services if s not in services_with_endpoints]

            if missing_services:
                services_without_endpoints.append({
                    'region': region,
                    'missing_services': missing_services,
                    'missing_count': len(missing_services),
                    'endpoint_coverage': len(services_with_endpoints) / len(critical_services) * 100
                })
                total_missing += len(missing_services)

        if services_without_endpoints:
            self.add_vulnerability(
                code='NET-018',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc_endpoint',
                    'identifiers': [f"{region}-{service}" for region_data in services_without_endpoints
                                    for service in region_data['missing_services']]
                }],
                evidence={
                    'regions_affected': services_without_endpoints,
                    'total_missing_endpoints': total_missing,
                    'critical_services_without_endpoints': list(set([
                        service for region_data in services_without_endpoints
                        for service in region_data['missing_services']
                    ])),
                    'security_impact': 'Tráfico sensible expuesto en Internet público',
                    'performance_impact': 'Mayor latencia y costos de transferencia'
                },
                remediation_steps=[
                    "Implementar VPC Endpoints para OBS (Object Storage)",
                    "Configurar VPC Endpoints para RDS y DDS (bases de datos)",
                    "Crear VPC Endpoints para ECS API calls",
                    "Implementar VPC Endpoints para KMS (gestión de llaves)",
                    "Configurar DNS privado con VPC Endpoints",
                    "Verificar políticas de acceso en VPC Endpoints"
                ]
            )
