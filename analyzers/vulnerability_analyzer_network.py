#!/usr/bin/env python3
"""
Analizador de vulnerabilidades para Network
Implementa controles NET-001 a NET-008 según security_references.csv
"""

from datetime import datetime
from typing import Dict, List, Any, Set
from .vulnerability_analyzer_base import VulnerabilityAnalyzerBase, VulnerabilityType


class NetworkVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Analizador específico para vulnerabilidades de red"""

    # Puertos críticos que no deberían estar expuestos
    CRITICAL_PORTS = {
        22: 'SSH',
        23: 'Telnet',
        135: 'RPC',
        139: 'NetBIOS',
        445: 'SMB',
        1433: 'SQL Server',
        1521: 'Oracle',
        3306: 'MySQL',
        3389: 'RDP',
        5432: 'PostgreSQL',
        5900: 'VNC',
        6379: 'Redis',
        7001: 'Cassandra',
        8020: 'Hadoop',
        9200: 'Elasticsearch',
        11211: 'Memcached',
        27017: 'MongoDB'
    }

    # Puertos de gestión que requieren protección especial
    MANAGEMENT_PORTS = {
        22: 'SSH',
        3389: 'RDP',
        5985: 'WinRM HTTP',
        5986: 'WinRM HTTPS',
        8443: 'HTTPS Management',
        9443: 'Management Console'
    }

    def analyze(self, network_data: Dict) -> List:
        """Analizar vulnerabilidades de red"""
        self.logger.info("Iniciando análisis de vulnerabilidades de red")

        # NET-001: VPC sin Segregación de Subnets
        self._check_vpc_subnet_segregation(network_data)

        # NET-002: Subnets Públicas sin Justificación
        self._check_public_subnets(network_data)

        # NET-003: Security Groups con Reglas Permisivas
        self._check_security_group_rules(network_data)

        # NET-004: Puertos Críticos Expuestos
        self._check_exposed_critical_ports(network_data)

        # NET-005: Ausencia de Network ACLs
        self._check_network_acls(network_data)

        # NET-006: VPC Peering sin Restricciones
        self._check_vpc_peering(network_data)

        # NET-007: ELB sin Cifrado SSL/TLS
        self._check_elb_encryption(network_data)

        # NET-008: Ausencia de Flow Logs
        self._check_flow_logs(network_data)

        return self.vulnerabilities

    def _check_vpc_subnet_segregation(self, network_data: Dict):
        """NET-001: Verificar segregación de subnets en VPCs"""
        vpcs_without_segregation = []

        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            vpc_id = vpc.get('id', 'Unknown')
            subnets = vpc.get('subnets', [])

            # Verificar si hay segregación por tipo (pública/privada)
            public_subnets = [s for s in subnets if s.get('is_public', False)]
            private_subnets = [
                s for s in subnets if not s.get('is_public', False)]

            # VPC sin segregación adecuada
            if len(subnets) > 0 and (len(public_subnets) == 0 or len(private_subnets) == 0):
                vpcs_without_segregation.append({
                    'vpc_id': vpc_id,
                    'vpc_name': vpc.get('name', 'Unknown'),
                    'total_subnets': len(subnets),
                    'public_subnets': len(public_subnets),
                    'private_subnets': len(private_subnets)
                })

        if vpcs_without_segregation:
            self.add_vulnerability(
                code='NET-001',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc',
                    'identifiers': [v['vpc_id'] for v in vpcs_without_segregation]
                }],
                evidence={
                    'vpcs': vpcs_without_segregation,
                    'total_affected': len(vpcs_without_segregation)
                },
                remediation_steps=[
                    "Implementar segregación de subnets por capas (DMZ, App, DB)",
                    "Crear subnets públicas solo para recursos que requieren acceso desde Internet",
                    "Implementar subnets privadas para recursos internos",
                    "Usar diferentes zonas de disponibilidad para alta disponibilidad"
                ]
            )

    def _check_public_subnets(self, network_data: Dict):
        """NET-002: Verificar subnets públicas sin justificación"""
        unjustified_public_subnets = []

        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            subnets = vpc.get('subnets', [])

            for subnet in subnets:
                if subnet.get('is_public', False):
                    # Verificar si tiene recursos que justifican ser pública
                    instances = subnet.get('instances', [])
                    has_nat = subnet.get('has_nat_gateway', False)
                    has_elb = subnet.get('has_load_balancer', False)

                    # Si es pública pero no tiene NAT, ELB o instancias con EIP
                    if not has_nat and not has_elb:
                        public_instances = [
                            i for i in instances if i.get('has_public_ip', False)]
                        if len(public_instances) == 0:
                            unjustified_public_subnets.append({
                                'subnet_id': subnet.get('id', 'Unknown'),
                                'subnet_name': subnet.get('name', 'Unknown'),
                                'vpc_id': vpc.get('id', 'Unknown'),
                                'cidr': subnet.get('cidr_block', 'Unknown')
                            })

        if unjustified_public_subnets:
            self.add_vulnerability(
                code='NET-002',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'subnet',
                    'identifiers': [s['subnet_id'] for s in unjustified_public_subnets]
                }],
                evidence={
                    'subnets': unjustified_public_subnets,
                    'total_affected': len(unjustified_public_subnets)
                },
                remediation_steps=[
                    "Revisar y justificar cada subnet pública",
                    "Convertir a privadas las subnets sin recursos públicos",
                    "Documentar la razón de negocio para subnets públicas",
                    "Implementar NAT Gateway para acceso saliente desde subnets privadas"
                ]
            )

    def _check_security_group_rules(self, network_data: Dict):
        """NET-003: Verificar security groups con reglas permisivas"""
        overly_permissive_sgs = []

        security_groups = network_data.get('security_groups', [])

        for sg in security_groups:
            sg_id = sg.get('id', 'Unknown')
            sg_name = sg.get('name', 'Unknown')

            # Verificar reglas de ingreso
            ingress_rules = sg.get('ingress_rules', [])

            for rule in ingress_rules:
                source = rule.get('source', '')
                from_port = rule.get('from_port', 0)
                to_port = rule.get('to_port', 0)
                protocol = rule.get('protocol', '')

                # Detectar reglas demasiado permisivas
                is_permissive = False
                reason = ""

                # Regla 0.0.0.0/0 con todos los puertos
                if source == '0.0.0.0/0' and from_port == 0 and to_port == 65535:
                    is_permissive = True
                    reason = "Permite todo el tráfico desde cualquier origen"

                # Regla 0.0.0.0/0 con puertos críticos
                elif source == '0.0.0.0/0' and from_port in self.CRITICAL_PORTS:
                    is_permissive = True
                    reason = f"Puerto crítico {from_port} ({self.CRITICAL_PORTS[from_port]}) expuesto a Internet"

                # Protocolo -1 (todos los protocolos)
                elif protocol == '-1' and source == '0.0.0.0/0':
                    is_permissive = True
                    reason = "Permite todos los protocolos desde Internet"

                if is_permissive:
                    overly_permissive_sgs.append({
                        'sg_id': sg_id,
                        'sg_name': sg_name,
                        'rule': {
                            'source': source,
                            'ports': f"{from_port}-{to_port}",
                            'protocol': protocol
                        },
                        'reason': reason
                    })

        if overly_permissive_sgs:
            self.add_vulnerability(
                code='NET-003',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'security_group',
                    'identifiers': list(set([sg['sg_id'] for sg in overly_permissive_sgs]))
                }],
                evidence={
                    # Limitar a 10 ejemplos
                    'permissive_rules': overly_permissive_sgs[:10],
                    'total_issues': len(overly_permissive_sgs)
                },
                remediation_steps=[
                    "Aplicar principio de menor privilegio en reglas de seguridad",
                    "Restringir acceso solo desde IPs o rangos conocidos",
                    "Usar Security Groups de origen en lugar de IPs cuando sea posible",
                    "Eliminar reglas con protocolo -1 o puerto 0-65535"
                ]
            )

    def _check_exposed_critical_ports(self, network_data: Dict):
        """NET-004: Verificar puertos críticos expuestos"""
        exposed_critical_ports = []

        # Verificar en security groups
        security_groups = network_data.get('security_groups', [])

        for sg in security_groups:
            ingress_rules = sg.get('ingress_rules', [])

            for rule in ingress_rules:
                source = rule.get('source', '')
                from_port = rule.get('from_port', 0)
                to_port = rule.get('to_port', 0)

                # Si la fuente es Internet (0.0.0.0/0)
                if source == '0.0.0.0/0' or source == '::/0':
                    # Verificar cada puerto crítico
                    for critical_port, service in self.CRITICAL_PORTS.items():
                        if from_port <= critical_port <= to_port:
                            exposed_critical_ports.append({
                                'sg_id': sg.get('id', 'Unknown'),
                                'sg_name': sg.get('name', 'Unknown'),
                                'port': critical_port,
                                'service': service,
                                'source': source
                            })

        # Verificar también en instancias con IPs públicas
        instances = network_data.get('instances', [])
        for instance in instances:
            if instance.get('has_public_ip', False):
                open_ports = instance.get('open_ports', [])
                for port in open_ports:
                    if port in self.CRITICAL_PORTS:
                        exposed_critical_ports.append({
                            'instance_id': instance.get('id', 'Unknown'),
                            'instance_name': instance.get('name', 'Unknown'),
                            'port': port,
                            'service': self.CRITICAL_PORTS[port],
                            'public_ip': '{{PUBLIC_IP}}'  # Sanitizado
                        })

        if exposed_critical_ports:
            self.add_vulnerability(
                code='NET-004',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'mixed',
                    'identifiers': list(set([
                        ep.get('sg_id', ep.get('instance_id', 'Unknown'))
                        for ep in exposed_critical_ports
                    ]))
                }],
                evidence={
                    # Limitar ejemplos
                    'exposed_ports': exposed_critical_ports[:15],
                    'total_exposures': len(exposed_critical_ports),
                    'unique_services': list(set([ep['service'] for ep in exposed_critical_ports]))
                },
                remediation_steps=[
                    "Cerrar puertos críticos al acceso desde Internet",
                    "Implementar VPN o bastion hosts para acceso administrativo",
                    "Usar servicios gestionados en lugar de exponer bases de datos",
                    "Implementar listas blancas de IPs para servicios críticos"
                ]
            )

    def _check_network_acls(self, network_data: Dict):
        """NET-005: Verificar ausencia de Network ACLs"""
        subnets_without_nacls = []

        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            subnets = vpc.get('subnets', [])

            for subnet in subnets:
                nacl = subnet.get('network_acl')

                # Verificar si usa NACL por defecto o no tiene NACL personalizada
                if not nacl or nacl.get('is_default', True):
                    subnets_without_nacls.append({
                        'subnet_id': subnet.get('id', 'Unknown'),
                        'subnet_name': subnet.get('name', 'Unknown'),
                        'vpc_id': vpc.get('id', 'Unknown'),
                        'is_public': subnet.get('is_public', False)
                    })

        if subnets_without_nacls:
            # Solo reportar si hay muchas subnets sin NACLs personalizadas
            if len(subnets_without_nacls) > 3:
                self.add_vulnerability(
                    code='NET-005',
                    type=VulnerabilityType.NETWORK,
                    affected_resources=[{
                        'type': 'subnet',
                        'identifiers': [s['subnet_id'] for s in subnets_without_nacls[:10]]
                    }],
                    evidence={
                        'subnets_without_custom_nacls': subnets_without_nacls[:10],
                        'total_affected': len(subnets_without_nacls)
                    },
                    remediation_steps=[
                        "Implementar Network ACLs personalizadas para defensa en profundidad",
                        "Configurar reglas específicas por subnet según su función",
                        "Priorizar NACLs en subnets públicas y DMZ",
                        "Documentar las reglas y su justificación"
                    ]
                )

    def _check_vpc_peering(self, network_data: Dict):
        """NET-006: Verificar VPC Peering sin restricciones"""
        unrestricted_peerings = []

        vpc_peerings = network_data.get('vpc_peerings', [])

        for peering in vpc_peerings:
            # Verificar si tiene restricciones de ruta o seguridad
            routes = peering.get('routes', [])

            # Verificar si permite todo el tráfico
            has_unrestricted_route = False
            for route in routes:
                if route.get('destination_cidr') == '0.0.0.0/0':
                    has_unrestricted_route = True
                    break

            # Verificar si no tiene security groups específicos
            if has_unrestricted_route or not peering.get('has_route_restrictions', True):
                unrestricted_peerings.append({
                    'peering_id': peering.get('id', 'Unknown'),
                    'requester_vpc': peering.get('requester_vpc_id', 'Unknown'),
                    'accepter_vpc': peering.get('accepter_vpc_id', 'Unknown'),
                    'status': peering.get('status', 'Unknown')
                })

        if unrestricted_peerings:
            self.add_vulnerability(
                code='NET-006',
                type=VulnerabilityType.NETWORK,
                affected_resources=[{
                    'type': 'vpc_peering',
                    'identifiers': [p['peering_id'] for p in unrestricted_peerings]
                }],
                evidence={
                    'unrestricted_peerings': unrestricted_peerings,
                    'total_affected': len(unrestricted_peerings)
                },
                remediation_steps=[
                    "Implementar rutas específicas en VPC peering",
                    "Evitar rutas 0.0.0.0/0 en conexiones peering",
                    "Documentar el propósito de cada conexión peering",
                    "Implementar security groups restrictivos en recursos compartidos"
                ]
            )

    def _check_elb_encryption(self, network_data: Dict):
        """NET-007: Verificar ELB sin cifrado SSL/TLS"""
        unencrypted_elbs = []
        weak_tls_elbs = []

        load_balancers = network_data.get('load_balancers', [])

        for elb in load_balancers:
            elb_id = elb.get('id', 'Unknown')
            elb_name = elb.get('name', 'Unknown')

            # Verificar listeners
            listeners = elb.get('listeners', [])

            for listener in listeners:
                protocol = listener.get('protocol', '').upper()
                port = listener.get('port', 0)

                # Verificar si usa HTTP en lugar de HTTPS
                if protocol == 'HTTP' and port in [80, 8080, 8000]:
                    unencrypted_elbs.append({
                        'elb_id': elb_id,
                        'elb_name': elb_name,
                        'listener_port': port,
                        'protocol': protocol
                    })

                # Verificar versión de TLS si usa HTTPS
                if protocol == 'HTTPS':
                    tls_version = listener.get(
                        'ssl_policy', {}).get('min_tls_version', '')
                    if tls_version in ['TLSv1.0', 'TLSv1.1', 'SSLv3']:
                        weak_tls_elbs.append({
                            'elb_id': elb_id,
                            'elb_name': elb_name,
                            'tls_version': tls_version
                        })

        if unencrypted_elbs or weak_tls_elbs:
            evidence = {}
            if unencrypted_elbs:
                evidence['unencrypted_listeners'] = unencrypted_elbs
            if weak_tls_elbs:
                evidence['weak_tls_configs'] = weak_tls_elbs

            self.add_vulnerability(
                code='NET-007',
                type=VulnerabilityType.ENCRYPTION,
                affected_resources=[{
                    'type': 'elb',
                    'identifiers': list(set([
                        e['elb_id'] for e in unencrypted_elbs + weak_tls_elbs
                    ]))
                }],
                evidence=evidence,
                remediation_steps=[
                    "Habilitar HTTPS en todos los ELBs públicos",
                    "Configurar redirección de HTTP a HTTPS",
                    "Usar TLS 1.2 como versión mínima",
                    "Implementar certificados SSL válidos",
                    "Configurar políticas de seguridad SSL recomendadas"
                ]
            )

    def _check_flow_logs(self, network_data: Dict):
        """NET-008: Verificar ausencia de Flow Logs"""
        resources_without_flow_logs = []

        # Verificar VPCs sin flow logs
        vpcs = network_data.get('vpcs', [])
        for vpc in vpcs:
            if not vpc.get('flow_logs_enabled', False):
                resources_without_flow_logs.append({
                    'type': 'vpc',
                    'id': vpc.get('id', 'Unknown'),
                    'name': vpc.get('name', 'Unknown')
                })

        # Verificar subnets críticas sin flow logs
        for vpc in vpcs:
            subnets = vpc.get('subnets', [])
            for subnet in subnets:
                # Solo verificar subnets públicas o con recursos críticos
                if subnet.get('is_public', False) and not subnet.get('flow_logs_enabled', False):
                    resources_without_flow_logs.append({
                        'type': 'subnet',
                        'id': subnet.get('id', 'Unknown'),
                        'name': subnet.get('name', 'Unknown'),
                        'vpc_id': vpc.get('id', 'Unknown')
                    })

        if resources_without_flow_logs:
            self.add_vulnerability(
                code='NET-008',
                type=VulnerabilityType.LOGGING,
                affected_resources=[{
                    'type': 'network_resource',
                    'identifiers': [r['id'] for r in resources_without_flow_logs[:20]]
                }],
                evidence={
                    'resources_without_logs': resources_without_flow_logs[:10],
                    'total_affected': len(resources_without_flow_logs),
                    'vpcs_affected': len([r for r in resources_without_flow_logs if r['type'] == 'vpc']),
                    'subnets_affected': len([r for r in resources_without_flow_logs if r['type'] == 'subnet'])
                },
                remediation_steps=[
                    "Habilitar VPC Flow Logs en todas las VPCs",
                    "Configurar retención adecuada (mínimo 90 días)",
                    "Centralizar logs en servicio de análisis",
                    "Implementar alertas para tráfico anómalo",
                    "Documentar exclusiones si las hay"
                ]
            )

    def _analyze_network_segmentation(self, network_data: Dict) -> Dict:
        """Análisis adicional de segmentación de red"""
        segmentation_issues = {
            'flat_networks': [],
            'missing_dmz': [],
            'cross_environment_connections': []
        }

        vpcs = network_data.get('vpcs', [])

        for vpc in vpcs:
            vpc_name = vpc.get('name', '').lower()
            subnets = vpc.get('subnets', [])

            # Detectar redes planas (sin segmentación)
            subnet_types = set()
            for subnet in subnets:
                if 'public' in subnet.get('name', '').lower():
                    subnet_types.add('public')
                elif 'private' in subnet.get('name', '').lower():
                    subnet_types.add('private')
                elif 'dmz' in subnet.get('name', '').lower():
                    subnet_types.add('dmz')
                elif 'data' in subnet.get('name', '').lower():
                    subnet_types.add('data')

            if len(subnet_types) < 2 and len(subnets) > 2:
                segmentation_issues['flat_networks'].append(vpc.get('id'))

            # Detectar falta de DMZ en VPCs con recursos públicos
            if 'public' in subnet_types and 'dmz' not in subnet_types:
                segmentation_issues['missing_dmz'].append(vpc.get('id'))

            # Detectar conexiones entre ambientes
            if any(env in vpc_name for env in ['prod', 'production']):
                peerings = vpc.get('peering_connections', [])
                for peer in peerings:
                    peer_vpc_name = peer.get('peer_vpc_name', '').lower()
                    if any(env in peer_vpc_name for env in ['dev', 'test', 'qa']):
                        segmentation_issues['cross_environment_connections'].append({
                            'prod_vpc': vpc.get('id'),
                            'non_prod_vpc': peer.get('peer_vpc_id')
                        })

        return segmentation_issues

    def _check_internet_gateways(self, network_data: Dict):
        """Verificación adicional de Internet Gateways"""
        igw_issues = []

        internet_gateways = network_data.get('internet_gateways', [])

        for igw in internet_gateways:
            attached_vpcs = igw.get('attached_vpcs', [])

            # Verificar IGWs attached a múltiples VPCs (no debería ser posible, pero verificar)
            if len(attached_vpcs) > 1:
                igw_issues.append({
                    'igw_id': igw.get('id'),
                    'issue': 'attached_to_multiple_vpcs',
                    'vpc_count': len(attached_vpcs)
                })

            # Verificar IGWs sin uso
            for vpc_id in attached_vpcs:
                vpc_data = next((v for v in network_data.get(
                    'vpcs', []) if v.get('id') == vpc_id), None)
                if vpc_data:
                    has_public_subnet = any(s.get('is_public')
                                            for s in vpc_data.get('subnets', []))
                    if not has_public_subnet:
                        igw_issues.append({
                            'igw_id': igw.get('id'),
                            'issue': 'attached_but_no_public_subnets',
                            'vpc_id': vpc_id
                        })

        return igw_issues
