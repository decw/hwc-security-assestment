#!/usr/bin/env python3
"""
Coordinador de módulos de análisis de vulnerabilidades
Importa y coordina todos los analyzers específicos por dominio
"""

from typing import Dict, List, Any
from datetime import datetime

# Importar analyzers específicos por dominio
from .vulnerability_analyzer_base import VulnerabilityAnalyzerBase, VulnerabilityType
from .vulnerability_analyzer_iam import IAMVulnerabilityAnalyzer
from .vulnerability_analyzer_network import NetworkVulnerabilityAnalyzer


class ModuleVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Coordinador principal de análisis de vulnerabilidades por módulo"""

    def __init__(self, logger=None):
        super().__init__(logger)

        # Inicializar analyzers específicos
        self.iam_analyzer = IAMVulnerabilityAnalyzer(logger)
        self.network_analyzer = NetworkVulnerabilityAnalyzer(logger)

        # Storage y Monitoring se pueden agregar después
        # self.storage_analyzer = StorageVulnerabilityAnalyzer(logger)
        # self.monitoring_analyzer = MonitoringVulnerabilityAnalyzer(logger)

    def analyze_iam_vulnerabilities(self, iam_data: Dict) -> List:
        """Analizar vulnerabilidades IAM usando el analyzer específico"""
        self.logger.info("Delegando análisis IAM al módulo específico")

        # Ejecutar análisis con el módulo IAM
        iam_vulnerabilities = self.iam_analyzer.analyze(iam_data)

        # Agregar las vulnerabilidades encontradas a la lista principal
        self.vulnerabilities.extend(iam_vulnerabilities)

        return iam_vulnerabilities

    def analyze_network_vulnerabilities(self, network_data: Dict) -> List:
        """Analizar vulnerabilidades de red usando el analyzer específico"""
        self.logger.info("Delegando análisis de red al módulo específico")

        # Ejecutar análisis con el módulo Network
        network_vulnerabilities = self.network_analyzer.analyze(network_data)

        # Agregar las vulnerabilidades encontradas a la lista principal
        self.vulnerabilities.extend(network_vulnerabilities)

        return network_vulnerabilities

    def analyze_storage_vulnerabilities(self, storage_data: Dict) -> List:
        """Analizar vulnerabilidades de almacenamiento"""
        self.logger.info("Analizando vulnerabilidades de almacenamiento")

        # Por ahora, implementación básica hasta crear el módulo específico
        storage_vulnerabilities = []

        # STO-001: Volúmenes EVS sin cifrado
        unencrypted_volumes = storage_data.get('unencrypted_volumes', [])
        if unencrypted_volumes:
            self.add_vulnerability(
                code='STO-001',
                type=VulnerabilityType.ENCRYPTION,
                affected_resources=[{
                    'type': 'evs_volume',
                    'identifiers': [v.get('id', 'Unknown') for v in unencrypted_volumes[:10]]
                }],
                evidence={
                    'unencrypted_volumes': len(unencrypted_volumes),
                    'sample_volumes': unencrypted_volumes[:5]
                }
            )

        # STO-002: Buckets OBS públicos
        public_buckets = storage_data.get('public_buckets', [])
        if public_buckets:
            self.add_vulnerability(
                code='STO-002',
                type=VulnerabilityType.DATA_EXPOSURE,
                affected_resources=[{
                    'type': 'obs_bucket',
                    'identifiers': [b.get('name', 'Unknown') for b in public_buckets]
                }],
                evidence={
                    'public_buckets': public_buckets,
                    'total_count': len(public_buckets)
                }
            )

        return storage_vulnerabilities

    def analyze_monitoring_vulnerabilities(self, monitoring_data: Dict) -> List:
        """Analizar vulnerabilidades de monitoreo"""
        self.logger.info("Analizando vulnerabilidades de monitoreo")

        # Por ahora, implementación básica hasta crear el módulo específico
        monitoring_vulnerabilities = []

        # MON-001: Cloud Trace Service no configurado
        if not monitoring_data.get('cloud_trace_enabled', False):
            self.add_vulnerability(
                code='MON-001',
                type=VulnerabilityType.LOGGING,
                evidence={'message': 'Cloud Trace Service no está habilitado'}
            )

        # MON-002: Retención de logs insuficiente
        log_retention = monitoring_data.get('log_retention_days', 0)
        if log_retention < 90:
            self.add_vulnerability(
                code='MON-002',
                type=VulnerabilityType.LOGGING,
                evidence={
                    'current_retention_days': log_retention,
                    'required_retention_days': 90
                }
            )

        # MON-003: Alarmas críticas no configuradas
        critical_alarms = monitoring_data.get('critical_alarms', [])
        required_alarms = ['cpu_high', 'disk_full',
                           'memory_high', 'unauthorized_api_calls']
        missing_alarms = [
            a for a in required_alarms if a not in critical_alarms]

        if missing_alarms:
            self.add_vulnerability(
                code='MON-003',
                type=VulnerabilityType.MONITORING,
                evidence={'missing_alarms': missing_alarms}
            )

        return monitoring_vulnerabilities

    def analyze_cross_module_vulnerabilities(self, modules_data: Dict) -> List:
        """Analizar vulnerabilidades que cruzan múltiples módulos"""
        self.logger.info("Analizando vulnerabilidades cross-módulo")

        cross_vulnerabilities = []

        # Ejemplo: Verificar consistencia IAM-Network
        iam_data = modules_data.get('iam', {})
        network_data = modules_data.get('network', {})

        # Verificar si hay usuarios con acceso administrativo pero sin MFA en VPCs críticas
        admin_users = iam_data.get('permissions_analysis', {}).get(
            'users_with_admin_access', [])
        users_without_mfa = iam_data.get(
            'mfa_analysis', {}).get('users_without_mfa', [])

        admin_without_mfa = []
        for admin in admin_users:
            user_name = admin.get('user_name')
            if any(u.get('user_name') == user_name for u in users_without_mfa):
                admin_without_mfa.append(user_name)

        if admin_without_mfa and network_data.get('vpcs'):
            # Esto es crítico: admins sin MFA con acceso a infraestructura de red
            self.add_vulnerability(
                code='CROSS-001',
                type=VulnerabilityType.AUTHENTICATION,
                severity='CRITICAL',
                cvss_score=9.5,
                affected_resources=[{
                    'type': 'cross_module',
                    'identifiers': admin_without_mfa
                }],
                evidence={
                    'admin_users_without_mfa': admin_without_mfa,
                    'vpcs_at_risk': len(network_data.get('vpcs', []))
                },
                remediation_steps=[
                    "Habilitar MFA inmediatamente para todos los administradores",
                    "Implementar política de MFA obligatorio",
                    "Auditar accesos administrativos a recursos de red"
                ]
            )

        # Verificar recursos públicos sin logging adecuado
        public_resources = []

        # Subnets públicas
        for vpc in network_data.get('vpcs', []):
            for subnet in vpc.get('subnets', []):
                if subnet.get('is_public', False):
                    public_resources.append({
                        'type': 'subnet',
                        'id': subnet.get('id')
                    })

        # Si hay recursos públicos pero no hay logging
        monitoring_data = modules_data.get('monitoring', {})
        if public_resources and not monitoring_data.get('cloud_trace_enabled', False):
            self.add_vulnerability(
                code='CROSS-002',
                type=VulnerabilityType.LOGGING,
                severity='HIGH',
                cvss_score=7.5,
                affected_resources=public_resources[:10],
                evidence={
                    'public_resources_count': len(public_resources),
                    'logging_enabled': False
                },
                remediation_steps=[
                    "Habilitar Cloud Trace Service inmediatamente",
                    "Configurar logging para todos los recursos públicos",
                    "Implementar alertas para actividades sospechosas"
                ]
            )

        return cross_vulnerabilities

    def get_consolidated_summary(self) -> Dict:
        """Obtener resumen consolidado de todos los módulos"""
        summary = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_module': {
                'iam': len([v for v in self.vulnerabilities if v.code.startswith('IAM-')]),
                'network': len([v for v in self.vulnerabilities if v.code.startswith('NET-')]),
                'storage': len([v for v in self.vulnerabilities if v.code.startswith('STO-')]),
                'monitoring': len([v for v in self.vulnerabilities if v.code.startswith('MON-')]),
                'cross_module': len([v for v in self.vulnerabilities if v.code.startswith('CROSS-')])
            },
            'by_severity': {
                'CRITICAL': len([v for v in self.vulnerabilities if v.severity == 'CRITICAL']),
                'HIGH': len([v for v in self.vulnerabilities if v.severity == 'HIGH']),
                'MEDIUM': len([v for v in self.vulnerabilities if v.severity == 'MEDIUM']),
                'LOW': len([v for v in self.vulnerabilities if v.severity == 'LOW'])
            },
            'top_risks': self._get_top_risks(),
            'remediation_effort': self._calculate_total_remediation_effort(),
            'compliance_impact': self._assess_compliance_impact(),
            'timestamp': datetime.now().isoformat()
        }

        return summary

    def _get_top_risks(self, limit: int = 5) -> List[Dict]:
        """Obtener los principales riesgos ordenados por CVSS score"""
        sorted_vulns = sorted(
            self.vulnerabilities,
            key=lambda v: v.cvss_score,
            reverse=True
        )

        return [
            {
                'code': v.code,
                'title': v.title,
                'severity': v.severity,
                'cvss_score': v.cvss_score,
                'affected_resources_count': len(v.affected_resources)
            }
            for v in sorted_vulns[:limit]
        ]

    def _calculate_total_remediation_effort(self) -> Dict:
        """Calcular esfuerzo total de remediación"""
        total_hours = 0
        by_priority = {
            'immediate': 0,  # < 7 días
            'short_term': 0,  # 7-30 días
            'medium_term': 0,  # 30-90 días
            'long_term': 0  # > 90 días
        }

        for vuln in self.vulnerabilities:
            effort_hours = vuln.remediation.get('effort_hours', 8)
            total_hours += effort_hours

            time_days = vuln.remediation.get('time_days', 30)
            if time_days < 7:
                by_priority['immediate'] += effort_hours
            elif time_days < 30:
                by_priority['short_term'] += effort_hours
            elif time_days < 90:
                by_priority['medium_term'] += effort_hours
            else:
                by_priority['long_term'] += effort_hours

        return {
            'total_hours': total_hours,
            'total_days': total_hours / 8,  # Asumiendo 8 horas por día
            'by_priority': by_priority
        }

    def _assess_compliance_impact(self) -> Dict:
        """Evaluar impacto en cumplimiento normativo"""
        frameworks_affected = {
            'CIS': set(),
            'ISO_27001': set(),
            'NIST': set()
        }

        for vuln in self.vulnerabilities:
            if vuln.frameworks.get('CIS'):
                frameworks_affected['CIS'].add(vuln.frameworks['CIS'])
            if vuln.frameworks.get('ISO'):
                frameworks_affected['ISO_27001'].add(vuln.frameworks['ISO'])
            if vuln.frameworks.get('NIST'):
                frameworks_affected['NIST'].add(vuln.frameworks['NIST'])

        return {
            'frameworks_affected': {
                k: len(v) for k, v in frameworks_affected.items()
            },
            'high_impact_controls': self._identify_high_impact_controls()
        }

    def _identify_high_impact_controls(self) -> List[str]:
        """Identificar controles de alto impacto afectados"""
        high_impact = []

        critical_vulns = [
            v for v in self.vulnerabilities if v.severity == 'CRITICAL']
        for vuln in critical_vulns:
            for ref in vuln.references:
                if ref and 'critical' in ref.lower():
                    high_impact.append(ref)

        return list(set(high_impact))[:10]  # Top 10 controles críticos

    def export_modular_report(self) -> Dict:
        """Exportar reporte modular completo"""
        return {
            'summary': self.get_consolidated_summary(),
            'modules': {
                'iam': {
                    'vulnerabilities': [
                        v for v in self.export_vulnerabilities()
                        if v['code'].startswith('IAM-')
                    ],
                    'summary': self.iam_analyzer.get_summary() if self.iam_analyzer else {}
                },
                'network': {
                    'vulnerabilities': [
                        v for v in self.export_vulnerabilities()
                        if v['code'].startswith('NET-')
                    ],
                    'summary': self.network_analyzer.get_summary() if self.network_analyzer else {}
                },
                'storage': {
                    'vulnerabilities': [
                        v for v in self.export_vulnerabilities()
                        if v['code'].startswith('STO-')
                    ],
                    'summary': {}  # Se llenará cuando se cree el módulo
                },
                'monitoring': {
                    'vulnerabilities': [
                        v for v in self.export_vulnerabilities()
                        if v['code'].startswith('MON-')
                    ],
                    'summary': {}  # Se llenará cuando se cree el módulo
                },
                'cross_module': {
                    'vulnerabilities': [
                        v for v in self.export_vulnerabilities()
                        if v['code'].startswith('CROSS-')
                    ]
                }
            },
            'metadata': {
                'scan_date': datetime.now().isoformat(),
                'analyzer_version': '2.0.0',
                'modules_used': ['iam', 'network', 'storage', 'monitoring', 'cross_module'],
                'total_controls_evaluated': len(self.security_references),
                'framework_mapping': 'security_references.csv'
            }
        }
