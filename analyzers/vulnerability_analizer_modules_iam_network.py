#!/usr/bin/env python3
"""
Analizador de vulnerabilidades - Módulos IAM y Network
"""

from datetime import datetime
from typing import Dict, List, Any
from collections import defaultdict

from .vulnerability_analyzer_base import (
    VulnerabilityAnalyzerBase, Vulnerability, VulnerabilityType
)
from config.constants import CRITICAL_PORTS, PASSWORD_POLICY

class IAMNetworkVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Analizador de vulnerabilidades para módulos IAM y Network"""
    
    def get_vulnerabilities(self) -> List[Vulnerability]:
        """Obtener todas las vulnerabilidades encontradas"""
        return self.vulnerabilities
    
    def get_vulnerabilities_by_severity(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por severidad"""
        severity_counts = defaultdict(int)
        for vuln in self.vulnerabilities:
            severity_counts[vuln.severity] += 1
        return dict(severity_counts)
    
    def get_vulnerabilities_by_type(self) -> Dict[str, int]:
        """Obtener vulnerabilidades agrupadas por tipo"""
        type_counts = defaultdict(int)
        for vuln in self.vulnerabilities:
            type_counts[vuln.type.value] += 1
        return dict(type_counts)
    
    def analyze_iam_vulnerabilities(self, iam_data: Dict):
        """Analizar vulnerabilidades en IAM"""
        self.logger.info("Analizando vulnerabilidades IAM")
        
        # Usuarios sin MFA
        mfa_status = iam_data.get('mfa_status', {})
        users_without_mfa = mfa_status.get('users_without_mfa', [])
        
        if users_without_mfa:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'MFA'),
                title="Autenticación de factor único en cuentas privilegiadas",
                description=f"{len(users_without_mfa)} usuarios sin MFA habilitado, incluyendo posibles cuentas administrativas",
                type=VulnerabilityType.AUTHENTICATION,
                severity="HIGH",
                cvss_score=7.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_user',
                    'identifiers': [u['user_name'] for u in users_without_mfa]
                }],
                evidence={
                    'users_without_mfa': len(users_without_mfa),
                    'sample_users': users_without_mfa[:3]
                },
                remediation={
                    'steps': [
                        "Habilitar MFA obligatorio para todos los usuarios",
                        "Implementar política que requiera MFA para acceso a consola",
                        "Configurar MFA virtual o hardware según criticidad"
                    ],
                    'effort_hours': 8,
                    'priority': 'HIGH'
                },
                references=[
                    "https://docs.huaweicloud.com/iam/user-guide/iam_01_0026.html",
                    "CIS Control 4.5"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Políticas de contraseña débiles
        password_policy = iam_data.get('password_policy', {})
        policy_issues = self._check_password_policy_issues(password_policy)
        
        if policy_issues:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'PWPOLICY'),
                title="Política de contraseñas no cumple con estándares mínimos",
                description=f"La política actual tiene las siguientes debilidades: {', '.join(policy_issues)}",
                type=VulnerabilityType.AUTHENTICATION,
                severity="MEDIUM",
                cvss_score=5.3,
                cve_ids=[],
                affected_resources=[{
                    'type': 'account_policy',
                    'identifiers': ['password_policy']
                }],
                evidence={
                    'current_policy': password_policy,
                    'issues': policy_issues,
                    'required_policy': PASSWORD_POLICY
                },
                remediation={
                    'steps': [
                        "Actualizar política de contraseñas según estándares",
                        f"Establecer longitud mínima de {PASSWORD_POLICY['min_length']} caracteres",
                        "Requerir complejidad (mayúsculas, minúsculas, números, símbolos)",
                        f"Forzar cambio cada {PASSWORD_POLICY['max_age_days']} días"
                    ],
                    'effort_hours': 4,
                    'priority': 'MEDIUM'
                },
                references=[
                    "NIST SP 800-63B",
                    "ISO 27001:2022 A.9.4.3"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Access Keys sin rotar
        old_keys = []
        access_keys = iam_data.get('access_keys', [])
        for key in access_keys:
            if key.get('age_days', 0) > 90 and key.get('status') == 'active':
                old_keys.append(key)
        
        if old_keys:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'OLDKEYS'),
                title="Access Keys sin rotación por más de 90 días",
                description=f"{len(old_keys)} access keys activas sin rotar por más de 90 días",
                type=VulnerabilityType.AUTHENTICATION,
                severity="MEDIUM",
                cvss_score=6.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'access_key',
                    'identifiers': [k['access_key_id'][:10] + '****' for k in old_keys[:5]]
                }],
                evidence={
                    'old_keys_count': len(old_keys),
                    'sample_keys': old_keys[:3]
                },
                remediation={
                    'steps': [
                        "Rotar access keys cada 90 días",
                        "Implementar proceso automatizado de rotación",
                        "Eliminar keys no utilizadas"
                    ],
                    'effort_hours': 6,
                    'priority': 'MEDIUM'
                },
                references=[
                    "CIS Control 4.3",
                    "NIST SP 800-53 AC-2"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Verificar privilegios excesivos
        self._check_excessive_privileges(iam_data)
        
        # Verificar políticas inseguras
        self._check_insecure_policies(iam_data)
    
    def analyze_network_vulnerabilities(self, network_data: Dict):
        """Analizar vulnerabilidades en Network"""
        self.logger.info("Analizando vulnerabilidades de red")
        
        # Verificar configuración de VPC
        self._check_vpc_configuration(network_data)
        
        # Verificar exposición de subnets
        self._check_subnet_exposure(network_data)
    
    def _check_excessive_privileges(self, iam_data: Dict):
        """Verificar privilegios excesivos"""
        privileged_users = []
        
        # Buscar usuarios con acceso administrativo
        permissions_analysis = iam_data.get('permissions_analysis', {})
        admin_users = permissions_analysis.get('users_with_admin_access', [])
        
        for admin in admin_users:
            privileged_users.append({
                'user_name': admin.get('user_name', 'Unknown'),
                'source': admin.get('source', 'Unknown')
            })
        
        if privileged_users:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'EXCESSIVE'),
                title="Usuarios con privilegios administrativos excesivos",
                description=f"{len(privileged_users)} usuarios con acceso administrativo completo",
                type=VulnerabilityType.AUTHORIZATION,
                severity="HIGH",
                cvss_score=8.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_user',
                    'identifiers': [u['user_name'] for u in privileged_users]
                }],
                evidence={
                    'privileged_users': privileged_users,
                    'total_count': len(privileged_users)
                },
                remediation={
                    'steps': [
                        "Implementar principio de menor privilegio",
                        "Crear roles específicos para funciones",
                        "Revisar y reducir permisos administrativos",
                        "Implementar acceso justo a tiempo (JIT)"
                    ],
                    'effort_hours': 12,
                    'priority': 'HIGH'
                },
                references=[
                    "CIS Control 6.8",
                    "NIST SP 800-53 AC-2"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_insecure_policies(self, iam_data: Dict):
        """Verificar políticas inseguras"""
        insecure_policies = []
        
        # Verificar políticas con permisos excesivos
        policies = iam_data.get('policies', [])
        for policy in policies:
            if self._is_policy_overly_permissive(policy):
                insecure_policies.append(policy)
        
        if insecure_policies:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'INSECUREPOL'),
                title="Políticas IAM con permisos excesivos",
                description=f"{len(insecure_policies)} políticas con permisos demasiado amplios",
                type=VulnerabilityType.AUTHORIZATION,
                severity="MEDIUM",
                cvss_score=6.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_policy',
                    'identifiers': [p.get('name', 'Unknown') for p in insecure_policies]
                }],
                evidence={
                    'insecure_policies': insecure_policies,
                    'total_count': len(insecure_policies)
                },
                remediation={
                    'steps': [
                        "Revisar y ajustar políticas según principio de menor privilegio",
                        "Eliminar permisos innecesarios",
                        "Implementar auditoría regular de políticas"
                    ],
                    'effort_hours': 8,
                    'priority': 'MEDIUM'
                },
                references=[
                    "CIS Control 1.3",
                    "NIST SP 800-53 AC-2"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _is_policy_overly_permissive(self, policy_doc: Dict) -> bool:
        """Verificar si una política es demasiado permisiva"""
        # Buscar patrones de permisos excesivos
        dangerous_patterns = [
            '"Action": ["*"]',
            '"Resource": ["*"]',
            '"Effect": "Allow"',
            'AdministratorAccess'
        ]
        
        policy_str = str(policy_doc)
        return any(pattern in policy_str for pattern in dangerous_patterns)
    
    def _check_vpc_configuration(self, network_data: Dict):
        """Verificar configuración de VPC"""
        vpcs = network_data.get('vpcs', [])
        
        for vpc in vpcs:
            # Verificar si VPC tiene configuración insegura
            if not vpc.get('enable_dns_hostnames', False):
                vuln = Vulnerability(
                    id=self._generate_vuln_id('NETWORK', 'VPCDNS'),
                    title="VPC sin DNS habilitado",
                    description=f"VPC {vpc.get('name', 'Unknown')} sin DNS habilitado",
                    type=VulnerabilityType.CONFIGURATION,
                    severity="LOW",
                    cvss_score=3.0,
                    cve_ids=[],
                    affected_resources=[{
                        'type': 'vpc',
                        'identifiers': [vpc.get('id', 'Unknown')]
                    }],
                    evidence={
                        'vpc_id': vpc.get('id'),
                        'vpc_name': vpc.get('name'),
                        'dns_enabled': vpc.get('enable_dns_hostnames', False)
                    },
                    remediation={
                        'steps': [
                            "Habilitar DNS en la VPC",
                            "Configurar DNS apropiado para la red"
                        ],
                        'effort_hours': 2,
                        'priority': 'LOW'
                    },
                    references=[
                        "AWS VPC Best Practices",
                        "CIS Control 4.1"
                    ],
                    discovered_date=datetime.now()
                )
                self.vulnerabilities.append(vuln)
    
    def _check_subnet_exposure(self, network_data: Dict):
        """Verificar exposición de subnets"""
        subnets = network_data.get('subnets', [])
        
        for subnet in subnets:
            if self._is_public_subnet(subnet) and not self._requires_public_access(subnet):
                vuln = Vulnerability(
                    id=self._generate_vuln_id('NETWORK', 'PUBLICSUBNET'),
                    title="Subnet pública innecesaria",
                    description=f"Subnet {subnet.get('name', 'Unknown')} expuesta públicamente sin necesidad",
                    type=VulnerabilityType.EXPOSURE,
                    severity="MEDIUM",
                    cvss_score=5.5,
                    cve_ids=[],
                    affected_resources=[{
                        'type': 'subnet',
                        'identifiers': [subnet.get('id', 'Unknown')]
                    }],
                    evidence={
                        'subnet_id': subnet.get('id'),
                        'subnet_name': subnet.get('name'),
                        'is_public': True
                    },
                    remediation={
                        'steps': [
                            "Mover recursos a subnets privadas",
                            "Configurar NAT Gateway para acceso externo",
                            "Revisar necesidad de acceso público"
                        ],
                        'effort_hours': 6,
                        'priority': 'MEDIUM'
                    },
                    references=[
                        "AWS VPC Best Practices",
                        "CIS Control 4.1"
                    ],
                    discovered_date=datetime.now()
                )
                self.vulnerabilities.append(vuln)
    
    def _is_public_subnet(self, subnet: Dict) -> bool:
        """Verificar si una subnet es pública"""
        return subnet.get('map_public_ip_on_launch', False)
    
    def _requires_public_access(self, subnet: Dict) -> bool:
        """Verificar si una subnet requiere acceso público"""
        # Lógica para determinar si el acceso público es necesario
        # Por ejemplo, subnets con load balancers o bastion hosts
        return False  # Simplificado para el ejemplo