#!/usr/bin/env python3
"""
Analizador de vulnerabilidades - Módulos IAM y Network
"""

from datetime import datetime
from typing import Dict, List, Any

from .vulnerability_analyzer_base import (
    VulnerabilityAnalyzerBase, Vulnerability, VulnerabilityType
)
from config.constants import CRITICAL_PORTS, PASSWORD_POLICY

class IAMNetworkVulnerabilityAnalyzer(VulnerabilityAnalyzerBase):
    """Analizador de vulnerabilidades para módulos IAM y Network"""
    
    def analyze_iam_vulnerabilities(self, iam_data: Dict):
        """Analizar vulnerabilidades en IAM"""
        self.logger.info("Analizando vulnerabilidades IAM")
        
        # Usuarios sin MFA
        mfa_status = iam_data.get('mfa_status', {})
        users_without_mfa = mfa_status.get('users_without_mfa', [])
        
        if users_without_mfa:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'MFA'),
                title="Autenticación de factor único en cuentas privilegiadas",
                description=f"{len(users_without_mfa)} usuarios sin MFA habilitado, incluyendo posibles cuentas administrativas",
                type=VulnerabilityType.AUTHENTICATION,
                severity="HIGH",
                cvss_score=7.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_user',
                    'identifiers': [u['user_name'] for u in users_without_mfa]
                }],
                evidence={
                    'users_without_mfa': len(users_without_mfa),
                    'sample_users': users_without_mfa[:3]
                },
                remediation={
                    'steps': [
                        "Habilitar MFA obligatorio para todos los usuarios",
                        "Implementar política que requiera MFA para acceso a consola",
                        "Configurar MFA virtual o hardware según criticidad"
                    ],
                    'effort_hours': 8,
                    'priority': 'HIGH'
                },
                references=[
                    "https://docs.huaweicloud.com/iam/user-guide/iam_01_0026.html",
                    "CIS Control 4.5"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Políticas de contraseña débiles
        password_policy = iam_data.get('password_policy', {})
        policy_issues = self._check_password_policy_issues(password_policy)
        
        if policy_issues:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'PWPOLICY'),
                title="Política de contraseñas no cumple con estándares mínimos",
                description=f"La política actual tiene las siguientes debilidades: {', '.join(policy_issues)}",
                type=VulnerabilityType.AUTHENTICATION,
                severity="MEDIUM",
                cvss_score=5.3,
                cve_ids=[],
                affected_resources=[{
                    'type': 'account_policy',
                    'identifiers': ['password_policy']
                }],
                evidence={
                    'current_policy': password_policy,
                    'issues': policy_issues,
                    'required_policy': PASSWORD_POLICY
                },
                remediation={
                    'steps': [
                        "Actualizar política de contraseñas según estándares",
                        f"Establecer longitud mínima de {PASSWORD_POLICY['min_length']} caracteres",
                        "Requerir complejidad (mayúsculas, minúsculas, números, símbolos)",
                        f"Forzar cambio cada {PASSWORD_POLICY['max_age_days']} días"
                    ],
                    'effort_hours': 4,
                    'priority': 'MEDIUM'
                },
                references=[
                    "NIST SP 800-63B",
                    "ISO 27001:2022 A.9.4.3"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Access Keys sin rotar
        old_keys = []
        for key in iam_data.get('access_keys', []):
            if key.get('age_days', 0) > 90:
                old_keys.append(key)
        
        if old_keys:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'KEYAGE'),
                title="Access Keys sin rotación periódica",
                description=f"{len(old_keys)} access keys activas por más de 90 días sin rotación",
                type=VulnerabilityType.ACCESS_CONTROL,
                severity="MEDIUM",
                cvss_score=6.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'access_key',
                    'identifiers': [k['access_key_id'][:10] + '****' for k in old_keys]
                }],
                evidence={
                    'old_keys_count': len(old_keys),
                    'max_age_days': max(k.get('age_days', 0) for k in old_keys),
                    'affected_users': list(set(k.get('user_name', '') for k in old_keys))
                },
                remediation={
                    'steps': [
                        "Implementar rotación automática de keys cada 90 días",
                        "Revocar keys antiguas después de crear nuevas",
                        "Usar IAM roles en lugar de keys donde sea posible",
                        "Monitorear uso de keys para detectar inactividad"
                    ],
                    'effort_hours': 16,
                    'priority': 'MEDIUM'
                },
                references=[
                    "CIS Control 1.12",
                    "PCI DSS 8.2.4"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
        
        # Verificar usuarios con privilegios excesivos
        self._check_excessive_privileges(iam_data)
        
        # Verificar políticas IAM inseguras
        self._check_insecure_policies(iam_data)
    
    def analyze_network_vulnerabilities(self, network_data: Dict):
        """Analizar vulnerabilidades de red"""
        self.logger.info("Analizando vulnerabilidades de red")
        
        # Recursos expuestos a Internet
        exposed_resources = network_data.get('exposed_resources', [])
        
        for resource in exposed_resources:
            critical_ports = [p for p in resource.get('exposed_ports', []) 
                            if p['port'] in CRITICAL_PORTS]
            
            if critical_ports:
                vuln = Vulnerability(
                    id=self._generate_vuln_id('NET', f"EXP-{resource['server_id'][:8]}"),
                    title=f"Servicios críticos expuestos a Internet en {resource['server_name']}",
                    description=f"El servidor tiene {len(critical_ports)} puertos críticos expuestos públicamente",
                    type=VulnerabilityType.EXPOSURE,
                    severity="CRITICAL",
                    cvss_score=9.1,
                    cve_ids=self._find_related_cves(critical_ports),
                    affected_resources=[{
                        'type': 'ecs_instance',
                        'identifiers': [resource['server_id']],
                        'details': {
                            'name': resource['server_name'],
                            'public_ips': resource['public_ips'],
                            'exposed_ports': critical_ports
                        }
                    }],
                    evidence={
                        'exposed_ports': critical_ports,
                        'security_groups': resource.get('security_groups', []),
                        'public_ips': resource['public_ips']
                    },
                    remediation={
                        'steps': [
                            "Cerrar inmediatamente puertos administrativos al público",
                            "Implementar bastion host para acceso administrativo",
                            "Configurar VPN para acceso remoto seguro",
                            "Aplicar principio de zero trust en security groups"
                        ],
                        'effort_hours': 8,
                        'priority': 'CRITICAL'
                    },
                    references=[
                        "CIS Control 9.2",
                        "OWASP A05:2021 – Security Misconfiguration"
                    ],
                    discovered_date=datetime.now(),
                    false_positive_likelihood=0.05
                )
                self.vulnerabilities.append(vuln)
        
        # Security Groups demasiado permisivos
        for region, sgs in network_data.get('security_groups', {}).items():
            for sg in sgs:
                overly_permissive_rules = self._check_permissive_rules(sg)
                
                if overly_permissive_rules:
                    vuln = Vulnerability(
                        id=self._generate_vuln_id('NET', f"SG-{sg['id'][:8]}"),
                        title=f"Security Group con reglas excesivamente permisivas: {sg['name']}",
                        description=f"El security group tiene {len(overly_permissive_rules)} reglas que permiten acceso amplio",
                        type=VulnerabilityType.CONFIGURATION,
                        severity="HIGH",
                        cvss_score=7.5,
                        cve_ids=[],
                        affected_resources=[{
                            'type': 'security_group',
                            'identifiers': [sg['id']],
                            'details': {
                                'name': sg['name'],
                                'region': region,
                                'vpc_id': sg.get('vpc_id')
                            }
                        }],
                        evidence={
                            'permissive_rules': overly_permissive_rules,
                            'total_rules': len(sg.get('rules', []))
                        },
                        remediation={
                            'steps': [
                                "Aplicar principio de menor privilegio en reglas",
                                "Restringir fuentes a rangos IP específicos",
                                "Limitar puertos a los estrictamente necesarios",
                                "Documentar justificación para cada regla"
                            ],
                            'effort_hours': 6,
                            'priority': 'HIGH'
                        },
                        references=[
                            "AWS Security Best Practices",
                            "CIS Control 11"
                        ],
                        discovered_date=datetime.now()
                    )
                    self.vulnerabilities.append(vuln)
        
        # Verificar configuración de VPCs
        self._check_vpc_configuration(network_data)
        
        # Verificar exposición de subnets
        self._check_subnet_exposure(network_data)
    
    def _check_excessive_privileges(self, iam_data: Dict):
        """Verificar usuarios con privilegios excesivos"""
        # Buscar usuarios con políticas administrativas
        admin_users = []
        for user in iam_data.get('users', []):
            # Lógica para detectar usuarios admin
            # Esto dependería de la estructura real de datos de Huawei Cloud
            pass
        
        if admin_users:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'EXCESS-PRIV'),
                title="Usuarios con privilegios administrativos excesivos",
                description=f"{len(admin_users)} usuarios con permisos de administrador completo",
                type=VulnerabilityType.AUTHORIZATION,
                severity="HIGH",
                cvss_score=8.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_user',
                    'identifiers': [u['name'] for u in admin_users]
                }],
                evidence={
                    'admin_users': len(admin_users),
                    'sample_users': admin_users[:3]
                },
                remediation={
                    'steps': [
                        "Implementar principio de menor privilegio",
                        "Crear roles específicos para cada función",
                        "Remover permisos administrativos innecesarios",
                        "Implementar aprobación para acciones críticas"
                    ],
                    'effort_hours': 24,
                    'priority': 'HIGH'
                },
                references=[
                    "CIS Control 4.1",
                    "NIST AC-6"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _check_insecure_policies(self, iam_data: Dict):
        """Verificar políticas IAM inseguras"""
        insecure_policies = []
        
        for policy in iam_data.get('policies', []):
            # Verificar patrones inseguros en políticas
            policy_doc = policy.get('policy', {})
            if self._is_policy_overly_permissive(policy_doc):
                insecure_policies.append(policy)
        
        if insecure_policies:
            vuln = Vulnerability(
                id=self._generate_vuln_id('IAM', 'INSEC-POL'),
                title="Políticas IAM con permisos excesivamente amplios",
                description=f"{len(insecure_policies)} políticas permiten acciones '*' o recursos '*'",
                type=VulnerabilityType.AUTHORIZATION,
                severity="HIGH",
                cvss_score=7.5,
                cve_ids=[],
                affected_resources=[{
                    'type': 'iam_policy',
                    'identifiers': [p['name'] for p in insecure_policies]
                }],
                evidence={
                    'insecure_policies_count': len(insecure_policies),
                    'sample_policies': insecure_policies[:2]
                },
                remediation={
                    'steps': [
                        "Revisar y restringir políticas con wildcards",
                        "Especificar recursos exactos en lugar de '*'",
                        "Limitar acciones a las mínimas necesarias",
                        "Implementar políticas condicionales"
                    ],
                    'effort_hours': 16,
                    'priority': 'HIGH'
                },
                references=[
                    "IAM Best Practices",
                    "Principle of Least Privilege"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _is_policy_overly_permissive(self, policy_doc: Dict) -> bool:
        """Verificar si una política es demasiado permisiva"""
        # Buscar patrones peligrosos
        policy_str = str(policy_doc)
        dangerous_patterns = [
            '"Action": ["*"]',
            '"Action": "*"',
            '"Resource": ["*"]',
            '"Resource": "*"',
            '"Effect": "Allow".*"Action": "\\*"'
        ]
        
        return any(pattern in policy_str for pattern in dangerous_patterns)
    
    def _check_vpc_configuration(self, network_data: Dict):
        """Verificar configuración de VPCs"""
        for region, vpcs in network_data.get('vpcs', {}).items():
            for vpc in vpcs:
                # Verificar VPC sin flow logs
                if not vpc.get('flow_logs_enabled', False):
                    vuln = Vulnerability(
                        id=self._generate_vuln_id('NET', f"VPC-LOGS-{vpc['id'][:8]}"),
                        title=f"VPC sin Flow Logs habilitados: {vpc['name']}",
                        description="Los Flow Logs no están habilitados, limitando la capacidad de auditoría y detección",
                        type=VulnerabilityType.MONITORING,
                        severity="MEDIUM",
                        cvss_score=5.5,
                        cve_ids=[],
                        affected_resources=[{
                            'type': 'vpc',
                            'identifiers': [vpc['id']],
                            'details': {
                                'name': vpc['name'],
                                'region': region,
                                'cidr': vpc.get('cidr')
                            }
                        }],
                        evidence={
                            'flow_logs_enabled': False,
                            'vpc_id': vpc['id']
                        },
                        remediation={
                            'steps': [
                                "Habilitar VPC Flow Logs",
                                "Configurar retención adecuada",
                                "Integrar con herramientas de análisis",
                                "Configurar alertas para tráfico anómalo"
                            ],
                            'effort_hours': 4,
                            'priority': 'MEDIUM'
                        },
                        references=[
                            "CIS Control 6.5",
                            "NIST SI-4"
                        ],
                        discovered_date=datetime.now()
                    )
                    self.vulnerabilities.append(vuln)
    
    def _check_subnet_exposure(self, network_data: Dict):
        """Verificar exposición de subnets"""
        public_subnets = []
        
        for region, subnets in network_data.get('subnets', {}).items():
            for subnet in subnets:
                # Verificar si es subnet pública sin justificación
                if self._is_public_subnet(subnet) and not self._requires_public_access(subnet):
                    public_subnets.append({
                        'id': subnet['id'],
                        'name': subnet['name'],
                        'cidr': subnet['cidr'],
                        'region': region
                    })
        
        if public_subnets:
            vuln = Vulnerability(
                id=self._generate_vuln_id('NET', 'PUB-SUBNET'),
                title="Subnets públicas sin justificación clara",
                description=f"{len(public_subnets)} subnets configuradas como públicas sin necesidad aparente",
                type=VulnerabilityType.CONFIGURATION,
                severity="MEDIUM",
                cvss_score=6.0,
                cve_ids=[],
                affected_resources=[{
                    'type': 'subnet',
                    'identifiers': [s['id'] for s in public_subnets],
                    'details': public_subnets
                }],
                evidence={
                    'public_subnets': public_subnets,
                    'total_count': len(public_subnets)
                },
                remediation={
                    'steps': [
                        "Revisar necesidad de subnets públicas",
                        "Migrar recursos a subnets privadas donde sea posible",
                        "Usar NAT Gateway para acceso saliente",
                        "Documentar justificación para subnets públicas"
                    ],
                    'effort_hours': 20,
                    'priority': 'MEDIUM'
                },
                references=[
                    "Network Segmentation Best Practices",
                    "Zero Trust Architecture"
                ],
                discovered_date=datetime.now()
            )
            self.vulnerabilities.append(vuln)
    
    def _is_public_subnet(self, subnet: Dict) -> bool:
        """Determinar si una subnet es pública"""
        # Lógica específica de Huawei Cloud
        return bool(subnet.get('gateway_ip'))
    
    def _requires_public_access(self, subnet: Dict) -> bool:
        """Verificar si la subnet requiere acceso público"""
        public_keywords = ['dmz', 'public', 'frontend', 'lb', 'load-balancer', 'nat']
        subnet_name = subnet.get('name', '').lower()
        return any(keyword in subnet_name for keyword in public_keywords)