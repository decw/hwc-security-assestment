#!/usr/bin/env python3
"""
Storage Vulnerability Analyzer
Analiza vulnerabilidades en configuraciones de almacenamiento según security_references.csv
"""

import logging
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass, field
import pandas as pd
import os


@dataclass
class StorageVulnerability:
    """Estructura para vulnerabilidades de Storage"""
    code: str
    title: str
    severity: str
    cvss_score: float
    description: str
    affected_resources: List[str]
    evidence: Dict[str, Any]
    recommendation: str
    compliance_mapping: Dict[str, str] = field(default_factory=dict)
    remediation_effort: Dict[str, Any] = field(default_factory=dict)


class StorageVulnerabilityAnalyzer:
    """Analizador de vulnerabilidades para Storage basado en security_references.csv"""

    def __init__(self, csv_path: str = 'security_references.csv'):
        """
        Inicializar el analizador

        Args:
            csv_path: Ruta al archivo security_references.csv
        """
        self.logger = self._setup_logger()
        self.vulnerabilities: List[StorageVulnerability] = []
        self.storage_controls = self._load_storage_controls(csv_path)

    def _setup_logger(self) -> logging.Logger:
        """Configurar logger"""
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def _load_storage_controls(self, csv_path: str) -> Dict[str, Dict]:
        """
        Cargar controles de STORAGE desde el CSV

        Args:
            csv_path: Ruta al archivo CSV

        Returns:
            Diccionario con los controles de storage
        """
        controls = {}

        try:
            if os.path.exists(csv_path):
                df = pd.read_csv(csv_path)
                storage_df = df[df['Dominio'] == 'STORAGE']

                for _, row in storage_df.iterrows():
                    controls[row['Codigo']] = {
                        'control': row['Control'],
                        'description': row['Descripcion'],
                        'severity': row['Severidad'],
                        'cvss_score': float(row['CVSS_Score']) if pd.notna(row['CVSS_Score']) else 0.0,
                        'cis': row['Framework_CIS'] if pd.notna(row['Framework_CIS']) else None,
                        'iso': row['Framework_ISO'] if pd.notna(row['Framework_ISO']) else None,
                        'nist': row['Framework_NIST'] if pd.notna(row['Framework_NIST']) else None,
                        'remediation_days': int(row['Tiempo_Remediacion_Dias']) if pd.notna(row['Tiempo_Remediacion_Dias']) else 30,
                        'effort_hours': int(row['Esfuerzo_Horas']) if pd.notna(row['Esfuerzo_Horas']) else 4,
                        'recommendation': row['Recomendacion'] if pd.notna(row['Recomendacion']) else ''
                    }

                self.logger.info(
                    f"Cargados {len(controls)} controles de STORAGE desde {csv_path}")
            else:
                self.logger.warning(
                    f"Archivo {csv_path} no encontrado, usando controles predefinidos")
                controls = self._get_default_controls()

        except Exception as e:
            self.logger.error(f"Error cargando controles desde CSV: {str(e)}")
            controls = self._get_default_controls()

        return controls

    def _get_default_controls(self) -> Dict[str, Dict]:
        """Obtener controles predefinidos si el CSV no está disponible"""
        return {
            'STO-001': {
                'control': 'Volúmenes EVS sin Cifrado',
                'description': 'Volúmenes de almacenamiento sin cifrado habilitado',
                'severity': 'CRITICAL',
                'cvss_score': 8.6,
                'cis': 'CIS 5.1',
                'iso': 'ISO 27001 A.10.1.1',
                'nist': 'NIST PR.DS-1',
                'remediation_days': 7,
                'effort_hours': 4,
                'recommendation': 'Habilitar cifrado en todos los volúmenes EVS, especialmente producción'
            },
            'STO-002': {
                'control': 'Buckets OBS Públicos',
                'description': 'Buckets de Object Storage con acceso público no restringido',
                'severity': 'CRITICAL',
                'cvss_score': 9.1,
                'cis': 'CIS 5.2',
                'iso': 'ISO 27001 A.13.2.1',
                'nist': 'NIST PR.AC-3',
                'remediation_days': 1,
                'effort_hours': 2,
                'recommendation': 'Restringir acceso público en buckets OBS'
            },
            'STO-003': {
                'control': 'Ausencia de Versionado en OBS',
                'description': 'Buckets sin versionado habilitado para protección contra eliminación',
                'severity': 'MEDIUM',
                'cvss_score': 5.3,
                'cis': 'CIS 5.3',
                'iso': 'ISO 27001 A.12.3.1',
                'nist': 'NIST PR.IP-4',
                'remediation_days': 30,
                'effort_hours': 2,
                'recommendation': 'Habilitar versionado en buckets críticos'
            },
            'STO-004': {
                'control': 'Políticas de Lifecycle Ausentes',
                'description': 'Sin políticas de lifecycle para gestión de datos antiguos',
                'severity': 'LOW',
                'cvss_score': 3.1,
                'cis': 'CIS 5.4',
                'iso': 'ISO 27001 A.8.3.3',
                'nist': 'NIST PR.DS-3',
                'remediation_days': 60,
                'effort_hours': 4,
                'recommendation': 'Configurar políticas de lifecycle para optimizar costos'
            },
            'STO-005': {
                'control': 'Access Logging Deshabilitado',
                'description': 'Buckets sin logging de acceso habilitado',
                'severity': 'MEDIUM',
                'cvss_score': 4.3,
                'cis': 'CIS 5.5',
                'iso': 'ISO 27001 A.12.4.1',
                'nist': 'NIST DE.AE-3',
                'remediation_days': 30,
                'effort_hours': 2,
                'recommendation': 'Habilitar logging de acceso en buckets OBS'
            },
            'STO-006': {
                'control': 'KMS Keys sin Rotación',
                'description': 'Llaves de cifrado KMS sin política de rotación automática',
                'severity': 'HIGH',
                'cvss_score': 7.1,
                'cis': 'CIS 5.6',
                'iso': 'ISO 27001 A.10.1.2',
                'nist': 'NIST PR.DS-1',
                'remediation_days': 14,
                'effort_hours': 3,
                'recommendation': 'Configurar rotación automática de llaves KMS'
            },
            'STO-007': {
                'control': 'Snapshots sin Cifrado',
                'description': 'Snapshots de volúmenes sin cifrado aplicado',
                'severity': 'HIGH',
                'cvss_score': 7.5,
                'cis': 'CIS 5.7',
                'iso': 'ISO 27001 A.10.1.1',
                'nist': 'NIST PR.DS-1',
                'remediation_days': 14,
                'effort_hours': 4,
                'recommendation': 'Cifrar todos los snapshots de volúmenes'
            },
            'STO-008': {
                'control': 'Cross-Region Replication Ausente',
                'description': 'Sin replicación cross-region para datos críticos',
                'severity': 'MEDIUM',
                'cvss_score': 5.9,
                'cis': None,
                'iso': 'ISO 27001 A.17.1.2',
                'nist': 'NIST PR.IP-4',
                'remediation_days': 30,
                'effort_hours': 8,
                'recommendation': 'Implementar replicación cross-region para datos críticos'
            },
            'STO-009': {
                'control': 'Backups No Configurados',
                'description': 'Recursos sin políticas de backup automático configuradas',
                'severity': 'HIGH',
                'cvss_score': 7.5,
                'cis': None,
                'iso': 'ISO 27001 A.12.3.1',
                'nist': 'NIST PR.IP-4',
                'remediation_days': 7,
                'effort_hours': 6,
                'recommendation': 'Configurar CSBS/VBS para backups automáticos'
            },
            'STO-010': {
                'control': 'Vaults de Backup sin Inmutabilidad',
                'description': 'CBS/VBS vaults sin protección WORM contra ransomware',
                'severity': 'CRITICAL',
                'cvss_score': 9.0,
                'cis': 'CIS 5.8',
                'iso': 'ISO 27001 A.12.3.1',
                'nist': 'NIST PR.PT-5',
                'remediation_days': 3,
                'effort_hours': 3,
                'recommendation': 'Activar inmutabilidad (WORM) en todos los vaults de backup críticos'
            }
        }

    def analyze(self, storage_data: Dict) -> List[StorageVulnerability]:
        """
        Analizar datos de storage y detectar vulnerabilidades

        Args:
            storage_data: Datos recolectados por StorageCollector

        Returns:
            Lista de vulnerabilidades encontradas
        """
        self.vulnerabilities = []
        self.logger.info("Iniciando análisis de vulnerabilidades de Storage")

        # Ejecutar análisis por control
        self._check_sto_001_unencrypted_volumes(storage_data)
        self._check_sto_002_public_buckets(storage_data)
        self._check_sto_003_versioning_disabled(storage_data)
        self._check_sto_004_lifecycle_policies(storage_data)
        self._check_sto_005_access_logging(storage_data)
        self._check_sto_006_kms_rotation(storage_data)
        self._check_sto_007_unencrypted_snapshots(storage_data)
        self._check_sto_008_cross_region_replication(storage_data)
        self._check_sto_009_backup_configuration(storage_data)
        self._check_sto_010_backup_immutability(storage_data)

        self.logger.info(
            f"Análisis completado: {len(self.vulnerabilities)} vulnerabilidades encontradas")
        return self.vulnerabilities

    def _check_sto_001_unencrypted_volumes(self, data: Dict):
        """STO-001: Verificar volúmenes EVS sin cifrado"""
        control = self.storage_controls.get('STO-001', {})
        unencrypted_volumes = []

        for region, volumes in data.get('evs_volumes', {}).items():
            for volume in volumes:
                if not volume.get('encrypted', False):
                    unencrypted_volumes.append({
                        'id': volume['id'],
                        'name': volume.get('name', 'N/A'),
                        'region': region,
                        'size_gb': volume.get('size', 0),
                        'attached_to': volume.get('attached_to', 'Not attached')
                    })

        if unencrypted_volumes:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-001',
                title=control.get('control', 'Volúmenes EVS sin Cifrado'),
                severity=control.get('severity', 'CRITICAL'),
                cvss_score=control.get('cvss_score', 8.6),
                description=control.get('description', ''),
                affected_resources=[v['id'] for v in unencrypted_volumes],
                # Limitar a 5 ejemplos
                evidence={'unencrypted_volumes': unencrypted_volumes[:5]},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 7),
                    'hours': control.get('effort_hours', 4)
                }
            ))

    def _check_sto_002_public_buckets(self, data: Dict):
        """STO-002: Verificar buckets OBS públicos"""
        control = self.storage_controls.get('STO-002', {})
        public_buckets = []

        for region, buckets in data.get('obs_buckets', {}).items():
            for bucket in buckets:
                if bucket.get('is_public', False) or bucket.get('acl') == 'public-read':
                    public_buckets.append({
                        'name': bucket['name'],
                        'region': region,
                        'acl': bucket.get('acl', 'unknown'),
                        'object_count': bucket.get('object_count', 0)
                    })

        if public_buckets:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-002',
                title=control.get('control', 'Buckets OBS Públicos'),
                severity=control.get('severity', 'CRITICAL'),
                cvss_score=control.get('cvss_score', 9.1),
                description=control.get('description', ''),
                affected_resources=[b['name'] for b in public_buckets],
                evidence={'public_buckets': public_buckets},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 1),
                    'hours': control.get('effort_hours', 2)
                }
            ))

    def _check_sto_003_versioning_disabled(self, data: Dict):
        """STO-003: Verificar buckets sin versionado"""
        control = self.storage_controls.get('STO-003', {})
        buckets_without_versioning = []

        for region, buckets in data.get('obs_buckets', {}).items():
            for bucket in buckets:
                if not bucket.get('versioning_enabled', False):
                    buckets_without_versioning.append({
                        'name': bucket['name'],
                        'region': region,
                        'size_bytes': bucket.get('size_bytes', 0),
                        'criticality': bucket.get('tags', {}).get('criticality', 'unknown')
                    })

        if buckets_without_versioning:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-003',
                title=control.get('control', 'Ausencia de Versionado en OBS'),
                severity=control.get('severity', 'MEDIUM'),
                cvss_score=control.get('cvss_score', 5.3),
                description=control.get('description', ''),
                affected_resources=[b['name']
                                    for b in buckets_without_versioning],
                evidence={
                    'buckets_without_versioning': buckets_without_versioning},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 30),
                    'hours': control.get('effort_hours', 2)
                }
            ))

    def _check_sto_004_lifecycle_policies(self, data: Dict):
        """STO-004: Verificar políticas de lifecycle"""
        control = self.storage_controls.get('STO-004', {})
        buckets_without_lifecycle = []

        for region, buckets in data.get('obs_buckets', {}).items():
            for bucket in buckets:
                if not bucket.get('lifecycle_rules', []):
                    buckets_without_lifecycle.append({
                        'name': bucket['name'],
                        'region': region,
                        'size_bytes': bucket.get('size_bytes', 0)
                    })

        if buckets_without_lifecycle:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-004',
                title=control.get(
                    'control', 'Políticas de Lifecycle Ausentes'),
                severity=control.get('severity', 'LOW'),
                cvss_score=control.get('cvss_score', 3.1),
                description=control.get('description', ''),
                affected_resources=[b['name']
                                    for b in buckets_without_lifecycle],
                evidence={
                    'buckets_without_lifecycle': buckets_without_lifecycle},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 60),
                    'hours': control.get('effort_hours', 4)
                }
            ))

    def _check_sto_005_access_logging(self, data: Dict):
        """STO-005: Verificar logging de acceso en buckets"""
        control = self.storage_controls.get('STO-005', {})
        buckets_without_logging = []

        for region, buckets in data.get('obs_buckets', {}).items():
            for bucket in buckets:
                if not bucket.get('access_logging_enabled', False):
                    buckets_without_logging.append({
                        'name': bucket['name'],
                        'region': region,
                        'criticality': bucket.get('tags', {}).get('criticality', 'unknown')
                    })

        if buckets_without_logging:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-005',
                title=control.get('control', 'Access Logging Deshabilitado'),
                severity=control.get('severity', 'MEDIUM'),
                cvss_score=control.get('cvss_score', 4.3),
                description=control.get('description', ''),
                affected_resources=[b['name']
                                    for b in buckets_without_logging],
                evidence={'buckets_without_logging': buckets_without_logging},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 30),
                    'hours': control.get('effort_hours', 2)
                }
            ))

    def _check_sto_006_kms_rotation(self, data: Dict):
        """STO-006: Verificar rotación de llaves KMS"""
        control = self.storage_controls.get('STO-006', {})
        keys_without_rotation = []

        for region, keys in data.get('kms_keys', {}).items():
            for key in keys:
                if not key.get('rotation_enabled', False):
                    keys_without_rotation.append({
                        'id': key['id'],
                        'alias': key.get('alias', 'N/A'),
                        'region': region,
                        'age_days': self._calculate_age_days(key.get('created_at')),
                        'protected_resources': key.get('protected_resources_count', 0)
                    })

        if keys_without_rotation:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-006',
                title=control.get('control', 'KMS Keys sin Rotación'),
                severity=control.get('severity', 'HIGH'),
                cvss_score=control.get('cvss_score', 7.1),
                description=control.get('description', ''),
                affected_resources=[k['id'] for k in keys_without_rotation],
                evidence={'keys_without_rotation': keys_without_rotation[:5]},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 14),
                    'hours': control.get('effort_hours', 3)
                }
            ))

    def _check_sto_007_unencrypted_snapshots(self, data: Dict):
        """STO-007: Verificar snapshots sin cifrado"""
        control = self.storage_controls.get('STO-007', {})
        unencrypted_snapshots = []

        for region, snapshots in data.get('snapshots', {}).items():
            for snapshot in snapshots:
                if not snapshot.get('encrypted', False):
                    unencrypted_snapshots.append({
                        'id': snapshot['id'],
                        'name': snapshot.get('name', 'N/A'),
                        'region': region,
                        'volume_id': snapshot.get('volume_id', 'N/A'),
                        'size_gb': snapshot.get('size_gb', 0)
                    })

        if unencrypted_snapshots:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-007',
                title=control.get('control', 'Snapshots sin Cifrado'),
                severity=control.get('severity', 'HIGH'),
                cvss_score=control.get('cvss_score', 7.5),
                description=control.get('description', ''),
                affected_resources=[s['id'] for s in unencrypted_snapshots],
                evidence={'unencrypted_snapshots': unencrypted_snapshots[:5]},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 14),
                    'hours': control.get('effort_hours', 4)
                }
            ))

    def _check_sto_008_cross_region_replication(self, data: Dict):
        """STO-008: Verificar replicación cross-region"""
        control = self.storage_controls.get('STO-008', {})
        critical_data_without_replication = []

        # Verificar buckets críticos
        for region, buckets in data.get('obs_buckets', {}).items():
            for bucket in buckets:
                if bucket.get('tags', {}).get('criticality') == 'high':
                    if not bucket.get('cross_region_replication'):
                        critical_data_without_replication.append({
                            'type': 'OBS Bucket',
                            'name': bucket['name'],
                            'region': region,
                            'criticality': 'high'
                        })

        if critical_data_without_replication:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-008',
                title=control.get(
                    'control', 'Cross-Region Replication Ausente'),
                severity=control.get('severity', 'MEDIUM'),
                cvss_score=control.get('cvss_score', 5.9),
                description=control.get('description', ''),
                affected_resources=[r['name']
                                    for r in critical_data_without_replication],
                evidence={
                    'resources_without_replication': critical_data_without_replication},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 30),
                    'hours': control.get('effort_hours', 8)
                }
            ))

    def _check_sto_009_backup_configuration(self, data: Dict):
        """STO-009: Verificar configuración de backups"""
        control = self.storage_controls.get('STO-009', {})
        resources_without_backup = []

        # Verificar volúmenes sin política de backup
        for region, volumes in data.get('evs_volumes', {}).items():
            for volume in volumes:
                if not volume.get('backup_policy_id'):
                    resources_without_backup.append({
                        'type': 'EVS Volume',
                        'id': volume['id'],
                        'name': volume.get('name', 'N/A'),
                        'region': region,
                        'size_gb': volume.get('size', 0)
                    })

        if resources_without_backup:
            # Limitar a 10 ejemplos para no sobrecargar el reporte
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-009',
                title=control.get('control', 'Backups No Configurados'),
                severity=control.get('severity', 'HIGH'),
                cvss_score=control.get('cvss_score', 7.5),
                description=control.get('description', ''),
                affected_resources=[r['id']
                                    for r in resources_without_backup[:10]],
                evidence={
                    'resources_without_backup': resources_without_backup[:5],
                    'total_affected': len(resources_without_backup)
                },
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 7),
                    'hours': control.get('effort_hours', 6)
                }
            ))

    def _check_sto_010_backup_immutability(self, data: Dict):
        """STO-010: Verificar inmutabilidad en vaults de backup"""
        control = self.storage_controls.get('STO-010', {})
        vaults_without_immutability = []

        for region, vaults in data.get('backup_vaults', {}).items():
            for vault in vaults:
                if not vault.get('immutability_enabled', False) or not vault.get('worm_policy'):
                    vaults_without_immutability.append({
                        'id': vault['id'],
                        'name': vault.get('name', 'N/A'),
                        'region': region,
                        'type': vault.get('type', 'Unknown'),
                        'backup_count': vault.get('backup_count', 0)
                    })

        if vaults_without_immutability:
            self.vulnerabilities.append(StorageVulnerability(
                code='STO-010',
                title=control.get(
                    'control', 'Vaults de Backup sin Inmutabilidad'),
                severity=control.get('severity', 'CRITICAL'),
                cvss_score=control.get('cvss_score', 9.0),
                description=control.get('description', ''),
                affected_resources=[v['id']
                                    for v in vaults_without_immutability],
                evidence={
                    'vaults_without_immutability': vaults_without_immutability},
                recommendation=control.get('recommendation', ''),
                compliance_mapping={
                    'CIS': control.get('cis', ''),
                    'ISO': control.get('iso', ''),
                    'NIST': control.get('nist', '')
                },
                remediation_effort={
                    'days': control.get('remediation_days', 3),
                    'hours': control.get('effort_hours', 3)
                }
            ))

    def _calculate_age_days(self, created_at: str) -> int:
        """Calcular edad en días desde la fecha de creación"""
        try:
            if created_at:
                created_date = datetime.fromisoformat(
                    created_at.replace('Z', '+00:00'))
                age = datetime.now() - created_date.replace(tzinfo=None)
                return age.days
        except:
            pass
        return 0

    def get_summary(self) -> Dict:
        """
        Obtener resumen del análisis

        Returns:
            Diccionario con estadísticas del análisis
        """
        summary = {
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': {
                'CRITICAL': 0,
                'HIGH': 0,
                'MEDIUM': 0,
                'LOW': 0
            },
            'by_control': {},
            'total_affected_resources': 0,
            'compliance_gaps': {
                'CIS': set(),
                'ISO': set(),
                'NIST': set()
            }
        }

        for vuln in self.vulnerabilities:
            # Contar por severidad
            summary['by_severity'][vuln.severity] = summary['by_severity'].get(
                vuln.severity, 0) + 1

            # Contar por control
            summary['by_control'][vuln.code] = vuln.title

            # Contar recursos afectados
            summary['total_affected_resources'] += len(vuln.affected_resources)

            # Identificar gaps de compliance
            for framework, control in vuln.compliance_mapping.items():
                if control:
                    summary['compliance_gaps'][framework].add(control)

        # Convertir sets a listas para serialización
        for framework in summary['compliance_gaps']:
            summary['compliance_gaps'][framework] = list(
                summary['compliance_gaps'][framework])

        return summary

    def export_findings(self) -> List[Dict]:
        """
        Exportar hallazgos en formato para reporte

        Returns:
            Lista de hallazgos formateados
        """
        findings = []

        for vuln in self.vulnerabilities:
            finding = {
                'code': vuln.code,
                'title': vuln.title,
                'severity': vuln.severity,
                'cvss_score': vuln.cvss_score,
                'description': vuln.description,
                'affected_resources_count': len(vuln.affected_resources),
                # Muestra de 3
                'affected_resources_sample': vuln.affected_resources[:3],
                'evidence': vuln.evidence,
                'recommendation': vuln.recommendation,
                'compliance_mapping': vuln.compliance_mapping,
                'remediation_effort': vuln.remediation_effort,
                'priority': self._calculate_priority(vuln.severity, len(vuln.affected_resources))
            }
            findings.append(finding)

        # Ordenar por prioridad
        findings.sort(key=lambda x: x['priority'])

        return findings

    def _calculate_priority(self, severity: str, affected_count: int) -> int:
        """
        Calcular prioridad basada en severidad y recursos afectados

        Args:
            severity: Nivel de severidad
            affected_count: Número de recursos afectados

        Returns:
            Score de prioridad (menor = más prioritario)
        """
        severity_scores = {
            'CRITICAL': 1,
            'HIGH': 2,
            'MEDIUM': 3,
            'LOW': 4
        }

        base_score = severity_scores.get(severity, 5)

        # Ajustar por cantidad de recursos afectados
        if affected_count > 10:
            base_score -= 0.5
        elif affected_count > 5:
            base_score -= 0.3

        return base_score


# Función de prueba
if __name__ == "__main__":
    import json

    # Datos de prueba
    test_data = {
        'evs_volumes': {
            'LA-Santiago': [
                {'id': 'vol-001', 'name': 'test-vol', 'encrypted': False},
                {'id': 'vol-002', 'name': 'prod-vol', 'encrypted': True}
            ]
        },
        'obs_buckets': {
            'LA-Santiago': [
                {
                    'name': 'test-bucket',
                    'is_public': True,
                    'versioning_enabled': False,
                    'access_logging_enabled': False
                }
            ]
        }
    }

    analyzer = StorageVulnerabilityAnalyzer()
    vulnerabilities = analyzer.analyze(test_data)

    print(f"Vulnerabilidades encontradas: {len(vulnerabilities)}")
    for vuln in vulnerabilities:
        print(f"  - [{vuln.code}] {vuln.title} ({vuln.severity})")

    summary = analyzer.get_summary()
    print(f"\nResumen: {json.dumps(summary, indent=2)}")
